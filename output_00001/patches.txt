../patch/multimat/condinit.f90
!================================================================
!================================================================
!================================================================
!================================================================
subroutine condinit(x,u,dx,nn)
  use amr_parameters
  use hydro_parameters
  implicit none
  integer ::nn                            ! Number of cells
  real(dp)::dx                            ! Cell size
  real(dp),dimension(1:nvector,1:nvar)::u ! Conservative variables
  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position.
  !================================================================
  ! This routine generates initial conditions for RAMSES.
  ! Positions are in user units:
  ! x(i,1:3) are in [0,boxlen]**ndim.
  ! U is the conservative variable vector. Conventions are here:
  ! U(i,1): d, U(i,2:ndim+1): d.u,d.v,d.w and U(i,ndim+2): E.
  ! Q is the primitive variable vector. Conventions are here:
  ! Q(i,1): d, Q(i,2:ndim+1):u,v,w and Q(i,ndim+2): P.
  ! If nvar >= ndim+3, remaining variables are treated as passive
  ! scalars in the hydro solver. 
  ! U(:,:) and Q(:,:) are in user units.
  !================================================================
  integer::ivar,imat
  real(dp),dimension(1:nvector,1:npri),save::q   ! Primitive variables
  real(dp),dimension(1:nvector,1:nmat),save::f,g,kappa_mat ! Volume fraction and densities
  real(dp),dimension(1:nvector),save::ekin,dtot,eint,cs,kappa_hat

  ! Call built-in initial condition generator
  call region_condinit(x,q,f,g,dx,nn)

  ! Add here, if you wish, some user-defined initial conditions
  ! ........

  ! Convert primitive to conservative variables

  ! call inverse eos routine (f,g,d,p) -> (e,c)
  call eosinv(f,g,q,eint,cs,kappa_mat,kappa_hat,nn)

  ! density -> density
  u(1:nn,1)=q(1:nn,1)
  ! velocity -> momentum
  u(1:nn,2)=q(1:nn,1)*q(1:nn,2)
  ekin(1:nn)=0.5*q(1:nn,2)**2
#if NDIM>1
  u(1:nn,3)=q(1:nn,1)*q(1:nn,3)
  ekin(1:nn)=ekin(1:nn)+0.5*q(1:nn,3)**2
#endif
#if NDIM>2
  u(1:nn,4)=q(1:nn,1)*q(1:nn,4)
  ekin(1:nn)=ekin(1:nn)+0.5*q(1:nn,4)**2
#endif
  ! total energy (E = e + 0.5 rho u**2)
  u(1:nn,npri)=eint(1:nn)+q(1:nn,1)*ekin(1:nn)
  ! volume fraction -> volume fraction
  do imat=1,nmat
     u(1:nn,imat+npri)=f(1:nn,imat)
  end do
  ! fluid densities -> fluid densities
  do imat=1,nmat
     u(1:nn,imat+npri+nmat)=g(1:nn,imat)
  end do

end subroutine condinit
../patch/multimat/courant_fine.f90
subroutine courant_fine(ilevel)
  use amr_commons
  use hydro_commons
  use poisson_commons
  use mpi_mod
  implicit none
#ifndef WITHOUTMPI
  integer::info
#endif
  integer::ilevel
  !----------------------------------------------------------------------
  ! Using the Courant-Friedrich-Levy stability condition,               !
  ! this routine computes the maximum allowed time-step.                !
  !----------------------------------------------------------------------
  integer::i,ivar,idim,imat,ind,ncache,igrid,iskip
  integer::nleaf,ngrid,nx_loc
  integer,dimension(1:nvector),save::ind_grid,ind_cell,ind_leaf

  real(dp)::dt_lev,dx,vol,skip_loc,scale,dx_loc,fourpi,twopi
  real(kind=8)::mass_loc,ekin_loc,eint_loc,dt_loc
  real(kind=8)::mass_all,ekin_all,eint_all,dt_all
  real(dp),dimension(1:nvector,1:nvar),save::uu
  real(dp),dimension(1:nvector,1:ndim),save::gg

  real(dp),dimension(1:nvector),save::rloc
  real(dp),dimension(1:8)::xc
  integer ::ix,iy,iz

  if(numbtot(1,ilevel)==0)return
  if(verbose)write(*,111)ilevel

  mass_all=0.0d0; mass_loc=0.0d0
  ekin_all=0.0d0; ekin_loc=0.0d0
  eint_all=0.0d0; eint_loc=0.0d0
  dt_all=dtnew(ilevel); dt_loc=dt_all

  ! Mesh spacing at that level
  twopi=2.0d0*ACOS(-1.0d0)
  fourpi=4.0d0*ACOS(-1.0d0)
  dx=0.5D0**ilevel
  nx_loc=(icoarse_max-icoarse_min+1)
  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale
  vol=dx_loc**ndim
  skip_loc=dble(icoarse_min)

  ! Set position of cell centers relative to grid center
  do ind=1,twotondim
     iz=(ind-1)/4
     iy=(ind-1-4*iz)/2
     ix=(ind-1-2*iy-4*iz)
     xc(ind)=(dble(ix)-0.5D0)*dx
  end do
  
  ! Loop over active grids by vector sweeps
  ncache=active(ilevel)%ngrid
  do igrid=1,ncache,nvector
     ngrid=MIN(nvector,ncache-igrid+1)
     do i=1,ngrid
        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)
     end do
     
     ! Loop over cells
     do ind=1,twotondim        
        iskip=ncoarse+(ind-1)*ngridmax
        do i=1,ngrid
           ind_cell(i)=ind_grid(i)+iskip
        end do
        
        ! Gather leaf cells
        nleaf=0
        do i=1,ngrid
           if(son(ind_cell(i))==0)then
              nleaf=nleaf+1
              ind_leaf(nleaf)=ind_cell(i)
              rloc(nleaf)=(xg(ind_grid(i),1)+xc(ind)-skip_loc)*scale
           end if
        end do

        ! Gather hydro variables
        do ivar=1,nvar
           do i=1,nleaf
              uu(i,ivar)=uold(ind_leaf(i),ivar)
           end do
        end do
        
        ! Gather gravitational acceleration
        gg=0.0d0
        if(poisson)then
           do idim=1,ndim
              do i=1,nleaf
                 gg(i,idim)=f(ind_leaf(i),idim)
              end do
           end do
        end if
        
        ! Compute total mass
        if(geom==3)then
           do i=1,nleaf
              mass_loc=mass_loc+uu(i,1)*vol*(rloc(i)**2+dx_loc**2/12.0)*fourpi
           end do
        else if(geom==2)then
           do i=1,nleaf
              mass_loc=mass_loc+uu(i,1)*vol*rloc(i)*twopi
           end do
        else
           do i=1,nleaf
              mass_loc=mass_loc+uu(i,1)*vol
           end do
        endif

        ! Compute total energy
        if(geom==3)then
           do i=1,nleaf
              ekin_loc=ekin_loc+uu(i,ndim+2)*vol*(rloc(i)**2+dx_loc**2/12.0)*fourpi
           end do
        else if(geom==2)then
           do i=1,nleaf
              ekin_loc=ekin_loc+uu(i,ndim+2)*vol*rloc(i)*twopi
           end do
        else
           do i=1,nleaf
              ekin_loc=ekin_loc+uu(i,ndim+2)*vol
           end do
        endif

        ! Compute CFL time-step
        if(nleaf>0)then
           call cmpdt(uu,gg,rloc,dx_loc,dt_lev,nleaf)
           dt_loc=min(dt_loc,dt_lev)
        end if
        
     end do
     ! End loop over cells
     
  end do
  ! End loop over grids

  ! Compute global quantities
#ifndef WITHOUTMPI
  call MPI_ALLREDUCE(mass_loc,mass_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,&
       & MPI_COMM_WORLD,info)
  call MPI_ALLREDUCE(ekin_loc,ekin_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,&
       & MPI_COMM_WORLD,info)
  call MPI_ALLREDUCE(eint_loc,eint_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,&
       & MPI_COMM_WORLD,info)
  call MPI_ALLREDUCE(  dt_loc,  dt_all,1,MPI_DOUBLE_PRECISION,MPI_MIN,&
       & MPI_COMM_WORLD,info)
#endif
#ifdef WITHOUTMPI
  mass_all=mass_loc
  ekin_all=ekin_loc
  eint_all=eint_loc
  dt_all=dt_loc
#endif

  mass_tot=mass_tot+mass_all
  ekin_tot=ekin_tot+ekin_all
  eint_tot=eint_tot+eint_all
  dtnew(ilevel)=MIN(dtnew(ilevel),dt_all)

111 format('   Entering courant_fine for level ',I2)

end subroutine courant_fine
!###########################################################
!###########################################################
!###########################################################
!###########################################################
../patch/multimat/eos_cc.f90
!###########################################################
!###########################################################
!###########################################################
!###########################################################

subroutine eos(f,g,q,p,c,kappa_mat,kappa_hat,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  integer::ncell
  real(dp),dimension(1:nvector,1:nmat)::f,g,kappa_mat
  real(dp),dimension(1:nvector,1:npri)::q
  real(dp),dimension(1:nvector)::p,c,kappa_hat
  ! Compute total pressure and sound speed from total internal energy
  ! On entry:
  ! f is the volume fraction of each fluid
  ! g is the true density of each fluid
  ! q are the total primitive variables (d, u, eint)
  ! On exit:
  ! p is the total pressure
  ! c is the total sound speed
  integer::k,imat
  real(dp)::smallgamma,a0, e_c,P_c, delpc
  real(dp)::rho_0,C_v,T_0,E_1,E_2,A_1,A_2
  real(dp),dimension(1:nvector),save::ec_hat,pc_hat, alpha_hat
  real(dp),dimension(1:nvector),save::gamma_hat,delpc_hat

  kappa_hat(1:ncell)=zero
  alpha_hat(1:ncell)=zero
  pc_hat (1:ncell)=zero
  ec_hat(1:ncell)=zero
  delpc_hat(1:ncell)=zero
  gamma_hat(1:ncell)=zero
  ! Cochran-Chan EOS written in terms of the Mie-Grueneisen EOS 
  do imat = 1,nmat
    ! Get Mie-Grueneisen EOS parameters
    rho_0=eos_params(imat,1);C_v=eos_params(imat,2);T_0=eos_params(imat,3)
    E_1=eos_params(imat,4);E_2=eos_params(imat,5);A_1=eos_params(imat,6);A_2=eos_params(imat,7)
    smallgamma=eos_params(imat,8)
    ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
    a0 = one / (smallgamma-one) 
    do k = 1,ncell
      ! Update Mie-Gruneisen terms for each material
      e_c = -A_1 / (rho_0*(1. - E_1))  * (((rho_0/g(k,imat))**(1.-E_1))-1.) + A_2 / (rho_0*(1. - E_2)) * (((rho_0/g(k,imat))**(1.-E_2))-1.) - C_v * T_0
      P_c = A_1 * (rho_0/g(k,imat))**(-E_1) - A_2 * (rho_0/g(k,imat))**(-E_2)
      delpc = A_1 * E_1 * (g(k,imat)**(E_1-1)/rho_0**E_1) - A_2 * E_2 * (g(k,imat)**(E_2-1)/rho_0**E_2)
      ! Update total values
      alpha_hat(k) = alpha_hat(k) + f(k,imat) * a0
      ec_hat(k) = ec_hat(k) + f(k,imat) * e_c
      pc_hat(k) = pc_hat(k) + (f(k,imat)*a0*P_c) 
      delpc_hat(k) = delpc_hat(k) + (f(k,imat)*a0*delpc) 
     end do
  end do
  pc_hat(1:ncell) = pc_hat(1:ncell)/alpha_hat(1:ncell)
  delpc_hat(1:ncell) = delpc_hat(1:ncell)/alpha_hat(1:ncell)
  gamma_hat(1:ncell)=one/alpha_hat(1:ncell)+one
  do k = 1,ncell
    ! Calculate the pressure for given internal energy
    p(k) = (q(k,npri) - ec_hat(k)) / alpha_hat(k) + pc_hat(k)
  end do 

  do imat = 1,nmat
    rho_0=eos_params(imat,1);C_v=eos_params(imat,2);T_0=eos_params(imat,3)
    E_1=eos_params(imat,4);E_2=eos_params(imat,5);A_1=eos_params(imat,6);A_2=eos_params(imat,7)
    smallgamma=eos_params(imat,8)
    ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
    a0 = one / (smallgamma-one) 
    do k = 1,ncell
      ! Calculate the bulk moduli
      ! c_mat**2 = P_c' + smallgamma/rho * (P-P_c)
      kappa_mat(k,imat) = g(k,imat) * MAX(smallc**2, delpc+(smallgamma/g(k,imat))*(p(k)-P_c))
      kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
    end do
  end do
  ! We have calculated 1/kappa_hat so we invert it
  kappa_hat(1:ncell) = one / kappa_hat(1:ncell)
  ! Calculate the speed of sound (old method)
  do k = 1,ncell
    c(k) = delpc_hat(k)+(gamma_hat(k)/q(k,1))*(p(k)-pc_hat(k))
    c(k) = sqrt(max(c(k),smallc**2))
  end do
  ! Calculate the total speed of sound(new method)
  ! do k = 1,ncell 
  !    c(k) = kappa_hat(k) / q(k,1)
  !    c(k) = sqrt(max(c(k),smallc**2))
  ! end do
end subroutine eos

!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine eosinv(f,g,q,e,c,kappa_mat,kappa_hat,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  integer::ncell
  real(dp),dimension(1:nvector,1:nmat)::f,g,c_mat,kappa_mat
  real(dp),dimension(1:nvector,1:npri)::q
  real(dp),dimension(1:nvector)::e,c,kappa_hat
  ! Compute total internal energy and sound speed from total pressure
  ! On entry:
  ! f is the volume fraction of each fluid
  ! g is the true density of each fluid
  ! q are the total primitive variables (d, u, P)
  ! On exit:
  ! eint is the total internal energy
  ! c is the sound speed of each fluid 
  ! c_hat is the total sound speed
  integer::k,imat
  real(dp)::smallgamma,a0, e_c,P_c, delpc
  real(dp)::rho_0,C_v,T_0,E_1,E_2,A_1,A_2
  real(dp),dimension(1:nvector),save::ec_hat,pc_hat, alpha_hat
  real(dp),dimension(1:nvector),save::gamma_hat,delpc_hat

  kappa_hat(1:ncell)=zero
  alpha_hat(1:ncell)=zero
  pc_hat (1:ncell)=zero
  ec_hat(1:ncell)=zero
  delpc_hat(1:ncell)=zero
  gamma_hat(1:ncell)=zero
  ! Cochran-Chan EOS written in terms of the Mie-Grueneisen EOS 
  do imat = 1,nmat
    ! Get Mie-Grueneisen EOS parameters
    rho_0=eos_params(imat,1);C_v=eos_params(imat,2);T_0=eos_params(imat,3)
    E_1=eos_params(imat,4);E_2=eos_params(imat,5);A_1=eos_params(imat,6);A_2=eos_params(imat,7)
    smallgamma=eos_params(imat,8)
    ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
    a0 = one / (smallgamma-one) 
    do k = 1,ncell
      ! Update Mie-Gruneisen terms for each material
      e_c = -A_1 / (rho_0*(1. - E_1))  * (((rho_0/g(k,imat))**(1.-E_1))-1.) + A_2 / (rho_0*(1. - E_2)) * (((rho_0/g(k,imat))**(1.-E_2))-1.) - C_v * T_0
      P_c = A_1 * (rho_0/g(k,imat))**(-E_1) - A_2 * (rho_0/g(k,imat))**(-E_2)
      delpc = A_1 * E_1 * (g(k,imat)**(E_1-1)/rho_0**E_1) - A_2 * E_2 * (g(k,imat)**(E_2-1)/rho_0**E_2)
      ! Update total values
      alpha_hat(k) = alpha_hat(k) + f(k,imat) * a0
      ec_hat(k) = ec_hat(k) + f(k,imat) * e_c
      pc_hat(k) = pc_hat(k) + (f(k,imat)*a0*P_c) 
      delpc_hat(k) = delpc_hat(k) + (f(k,imat)*a0*delpc) 
    end do
  end do
  pc_hat(1:ncell) = pc_hat(1:ncell)/alpha_hat(1:ncell)
  delpc_hat(1:ncell) = delpc_hat(1:ncell)/alpha_hat(1:ncell)
  gamma_hat(1:ncell)=one/alpha_hat(1:ncell)+one
  ! Calculate the internal energy for given pressure
  do k=1,ncell
    e(k) = alpha_hat(k) * (q(k,npri)-pc_hat(k)) + ec_hat(k)
  end do
      
  do imat = 1,nmat
    rho_0=eos_params(imat,1);C_v=eos_params(imat,2);T_0=eos_params(imat,3)
    E_1=eos_params(imat,4);E_2=eos_params(imat,5);A_1=eos_params(imat,6);A_2=eos_params(imat,7)
    smallgamma=eos_params(imat,8)
    ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
    a0 = one / (smallgamma-one) 
    do k = 1,ncell
      ! Calculate the bulk moduli
      ! c_mat**2 = P_c' + smallgamma/rho * (P-P_c)
      kappa_mat(k,imat) = g(k,imat) * MAX(smallc**2, delpc+(smallgamma/g(k,imat))*(q(k,npri)-P_c))
      kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
    end do
  end do
  ! We have calculated 1/kappa_hat so we invert it
  kappa_hat(1:ncell) = one / kappa_hat(1:ncell)
  ! Calculate the speed of sound (old method)
  do k = 1,ncell
    c(k) = delpc_hat(k)+(gamma_hat(k)/q(k,1))*(q(k,npri)-pc_hat(k))
    c(k) = sqrt(max(c(k),smallc**2))
  end do
  ! Calculate the total speed of sound (new method)
  ! do k = 1,ncell 
  !    c(k) = kappa_hat(k) / q(k,1)
  !    c(k) = sqrt(max(c(k),smallc**2))
  ! end do
end subroutine eosinv../patch/multimat/eos_mg.f90
!###########################################################
!###########################################################
!###########################################################
!###########################################################

subroutine eos(f,g,q,p,c,kappa_mat,kappa_hat,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  integer::ncell
  real(dp),dimension(1:nvector,1:nmat)::f,g,kappa_mat
  real(dp),dimension(1:nvector,1:npri)::q
  real(dp),dimension(1:nvector)::p,c,kappa_hat
  ! Compute total pressure and sound speed from total internal energy
  ! On entry:
  ! f is the volume fraction of each fluid
  ! g is the true density of each fluid
  ! q are the total primitive variables (d, u, eint)
  ! On exit:
  ! p is the total pressure
  ! c is the total sound speed
  integer::k,imat
  real(dp)::p0,a0
  real(dp)::smallgamma,biggamma,e_0, rho_0,e_c,P_c, delpc
  real(dp),dimension(1:nvector),save::ec_hat,pc_hat, alpha_hat
  real(dp),dimension(1:nvector),save::gamma_hat,delpc_hat

  kappa_hat(1:ncell)=zero
  alpha_hat(1:ncell)=zero
  pc_hat (1:ncell)=zero
  ec_hat(1:ncell)=zero
  delpc_hat(1:ncell)=zero
  gamma_hat(1:ncell)=zero
  ! Mie-Gruneisen implementation trial
  do imat = 1,nmat
    ! Get Mie-Grueneisen EOS parameters
    smallgamma=eos_params(imat,1);biggamma=eos_params(imat,2);e_0=eos_params(imat,3);rho_0=eos_params(imat,4)
    ! Test case for checking whether the model works
    ! smallgamma=eos_params(imat,1); biggamma=0 ; p0=eos_params(imat,2)
    ! e_0 =  p0
    ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
    a0 = one / (smallgamma-one) 
    do k = 1,ncell
      ! Update Mie-Gruneisen terms for each material
      ! print *, g(k,imat)
      e_c = e_0 * (g(k,imat)/rho_0)**biggamma
      P_c = e_0 * (biggamma-one) * (g(k,imat)/rho_0)**biggamma
      delpc = (e_0/rho_0) * biggamma * (biggamma-one) * (g(k,imat)/rho_0)**(biggamma-one)
      ! Update total values
      alpha_hat(k) = alpha_hat(k) + f(k,imat) * a0
      ec_hat(k) = ec_hat(k) + f(k,imat) * e_c
      pc_hat(k) = pc_hat(k) + (f(k,imat)*a0*P_c) 
      delpc_hat(k) = delpc_hat(k) + (f(k,imat)*a0*delpc) 
    end do
  end do
  pc_hat(1:ncell) = pc_hat(1:ncell)/alpha_hat(1:ncell)
  delpc_hat(1:ncell) = delpc_hat(1:ncell)/alpha_hat(1:ncell)
  gamma_hat(1:ncell)=one/alpha_hat(1:ncell)+one
  do k = 1,ncell
    ! Calculate the pressure for given internal energy
    p(k) = (q(k,npri) - ec_hat(k)) / alpha_hat(k) + pc_hat(k)
  end do 

  do imat = 1,nmat
    smallgamma=eos_params(imat,1);biggamma=eos_params(imat,2);e_0=eos_params(imat,3);rho_0=eos_params(imat,4)
    ! smallgamma=eos_params(imat,1); biggamma=0 ; p0=eos_params(imat,2)
    ! e_0 =  p0
    ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
    a0 = one / (smallgamma-one) 
    do k = 1,ncell
      ! Calculate the bulk moduli
      ! c_mat**2 = P_c' + smallgamma/rho * (P-P_c)
      kappa_mat(k,imat) = g(k,imat) * MAX(smallc**2, delpc+(smallgamma/g(k,imat))*(p(k)-P_c))
      kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
    end do
  end do
  ! We have calculated 1/kappa_hat so we invert it
  kappa_hat(1:ncell) = one / kappa_hat(1:ncell)
  ! Calculate the speed of sound (old method)
  do k = 1,ncell
    c(k) = delpc_hat(k)+(gamma_hat(k)/q(k,1))*(p(k)-pc_hat(k))
    c(k) = sqrt(max(c(k),smallc**2))
  end do
  ! Calculate the total speed of sound(new method)
  ! do k = 1,ncell 
  !    c(k) = kappa_hat(k) / q(k,1)
  !    c(k) = sqrt(max(c(k),smallc**2))
  ! end do

end subroutine eos

!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine eosinv(f,g,q,e,c,kappa_mat,kappa_hat,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  integer::ncell
  real(dp),dimension(1:nvector,1:nmat)::f,g,c_mat,kappa_mat
  real(dp),dimension(1:nvector,1:npri)::q
  real(dp),dimension(1:nvector)::e,c,kappa_hat
  ! Compute total internal energy and sound speed from total pressure
  ! On entry:
  ! f is the volume fraction of each fluid
  ! g is the true density of each fluid
  ! q are the total primitive variables (d, u, P)
  ! On exit:
  ! eint is the total internal energy
  ! c is the sound speed of each fluid 
  ! c_hat is the total sound speed
  integer::k,imat
  real(dp)::p0,a0
  real(dp)::smallgamma,biggamma,e_0,rho_0,e_c,P_c, delpc
  real(dp),dimension(1:nvector),save::ec_hat,pc_hat, alpha_hat
  real(dp),dimension(1:nvector),save::gamma_hat,delpc_hat

  kappa_hat(1:ncell)=zero
  alpha_hat(1:ncell)=zero
  pc_hat (1:ncell)=zero
  ec_hat(1:ncell)=zero
  delpc_hat(1:ncell)=zero
  gamma_hat(1:ncell)=zero
  ! Mie-Gruneisen implementation trial
  do imat = 1,nmat
    ! Get Mie-Grueneisen EOS parameters
    smallgamma=eos_params(imat,1);biggamma=eos_params(imat,2);e_0=eos_params(imat,3);rho_0=eos_params(imat,4)
    ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
    ! Test case for checking whether the model works
    ! smallgamma=eos_params(imat,1); biggamma=0 ; p0=eos_params(imat,2)
    ! e_0 =  p0
    ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
    a0 = one / (smallgamma-one) 
    do k = 1,ncell
      ! Update Mie-Gruneisen terms for each material
      e_c = e_0 * (g(k,imat)/rho_0)**biggamma
      P_c = e_0 * (biggamma-one) * (g(k,imat)/rho_0)**biggamma
      delpc = (e_0/rho_0) * biggamma * (biggamma-one) * (g(k,imat)/rho_0)**(biggamma-one)
      ! Update total values
      alpha_hat(k) = alpha_hat(k) + f(k,imat) * a0
      ec_hat(k) = ec_hat(k) + f(k,imat) * e_c
      pc_hat(k) = pc_hat(k) + (f(k,imat)*a0*P_c) 
      delpc_hat(k) = delpc_hat(k) + (f(k,imat)*a0*delpc) 
      end do
  end do
  pc_hat(1:ncell) = pc_hat(1:ncell)/alpha_hat(1:ncell)
  delpc_hat(1:ncell) = delpc_hat(1:ncell)/alpha_hat(1:ncell)
  gamma_hat(1:ncell)=one/alpha_hat(1:ncell)+one
  ! Calculate the internal energy for given pressure
  do k=1,ncell
    e(k) = alpha_hat(k) * (q(k,npri)-pc_hat(k)) + ec_hat(k)
  end do
      
  do imat = 1,nmat
    smallgamma=eos_params(imat,1);biggamma=eos_params(imat,2);e_0=eos_params(imat,3);rho_0=eos_params(imat,4)
    ! smallgamma=eos_params(imat,1); biggamma=0 ; p0=eos_params(imat,2)
    ! e_0 =  p0
    ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
    a0 = one / (smallgamma-one) 
    do k = 1,ncell
      ! Calculate the bulk moduli
      ! c_mat**2 = P_c' + smallgamma/rho * (P-P_c)
      kappa_mat(k,imat) = g(k,imat) * MAX(smallc**2, delpc+(smallgamma/g(k,imat))*(q(k,npri)-P_c))
      kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
    end do
  end do
  ! We have calculated 1/kappa_hat so we invert it
  kappa_hat(1:ncell) = one / kappa_hat(1:ncell)
  ! Calculate the speed of sound (old method)
  do k = 1,ncell
    c(k) = delpc_hat(k)+(gamma_hat(k)/q(k,1))*(q(k,npri)-pc_hat(k))
    c(k) = sqrt(max(c(k),smallc**2))
  end do
  ! Calculate the total speed of sound (new method)
  ! do k = 1,ncell 
  !    c(k) = kappa_hat(k) / q(k,1)
  !    c(k) = sqrt(max(c(k),smallc**2))
  ! end do
end subroutine eosinv../patch/multimat/eos_sg.f90
!###########################################################
!###########################################################
!###########################################################
!###########################################################

subroutine eos(f,g,q,p,c,kappa_mat,kappa_hat,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  integer::ncell
  real(dp),dimension(1:nvector,1:nmat)::f,g,kappa_mat
  real(dp),dimension(1:nvector,1:npri)::q
  real(dp),dimension(1:nvector)::p,c,kappa_hat
  ! Compute total pressure and sound speed from total internal energy
  ! On entry:
  ! f is the volume fraction of each fluid
  ! g is the true density of each fluid
  ! q are the total primitive variables (d, u, eint)
  ! On exit:
  ! p is the total pressure
  ! c is the total sound speed
  integer::k,imat
  real(dp)::g0,p0,a0,b0
  real(dp),dimension(1:nvector),save::alpha_tot,beta_tot
  real(dp),dimension(1:nvector),save::gamma_tot,pinf_tot

  ! Initialize variables as zero and update them iteratively
  alpha_tot(1:ncell)=zero
  beta_tot (1:ncell)=zero
  do imat = 1,nmat
    ! Get stiffened gas EOS parameters
    g0=eos_params(imat,1); p0=eos_params(imat,2)
    a0=one/(g0-one); b0=p0*g0/(g0-one)
    ! p=(gamma-1)*e-gamma*pinf; e=beta+alpha*p
    do k = 1,ncell
        ! Update alpha_tot and beta_tot
        alpha_tot(k) = alpha_tot(k) + f(k,imat) * a0
        beta_tot (k) = beta_tot (k) + f(k,imat) * b0
    end do
  end do
  gamma_tot(1:ncell)=one/alpha_tot(1:ncell)+one
  pinf_tot (1:ncell)=beta_tot(1:ncell)/alpha_tot(1:ncell)/gamma_tot(1:ncell)
  ! Calculate the pressure for given internal energy
  do k = 1,ncell
     p(k) = (q(k,npri) - beta_tot(k)) / alpha_tot(k)
  end do
  ! Calculate the bulk modulus
  do imat = 1,nmat
    ! Get stiffened gas EOS parameters
    g0=eos_params(imat,1); p0=eos_params(imat,2)
    a0=one/(g0-one); b0=p0*g0/(g0-one)
    ! p=(gamma-1)*e-gamma*pinf; e=beta+alpha*p
    do k = 1,ncell
      kappa_mat(k,imat) = MAX(g(k,imat) * smallc**2, g0  * (p(k) + p0))
      kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
    end do
  end do
  kappa_hat(1:ncell)=one/kappa_hat(1:ncell)
  ! Calculate the speed of sound (old method)
  do k = 1,ncell
    c(k) = gamma_tot(k)*(p(k)+pinf_tot(k))/q(k,1)
    c(k) = sqrt(max(c(k),smallc**2))
  end do
  ! Calculate the total speed of sound (new method)
  ! do k = 1,ncell
  !    c(k) = kappa_hat(k) / q(k,1)
  !    c(k) = sqrt(max(c(k),smallc**2))
  ! end do   

end subroutine eos

!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine eosinv(f,g,q,e,c,kappa_mat,kappa_hat,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  integer::ncell
  real(dp),dimension(1:nvector,1:nmat)::f,g,c_mat,kappa_mat
  real(dp),dimension(1:nvector,1:npri)::q
  real(dp),dimension(1:nvector)::e,c,kappa_hat
  ! Compute total internal energy and sound speed from total pressure
  ! On entry:
  ! f is the volume fraction of each fluid
  ! g is the true density of each fluid
  ! q are the total primitive variables (d, u, P)
  ! On exit:
  ! eint is the total internal energy
  ! c is the sound speed of each fluid 
  ! c_hat is the total sound speed
  integer::k,imat
  real(dp)::g0,p0,a0,b0
  real(dp),dimension(1:nvector),save::alpha_tot,beta_tot
  real(dp),dimension(1:nvector),save::gamma_tot,pinf_tot

  ! Initialize variables as zero and update them iteratively
  alpha_tot(1:ncell)=zero
  beta_tot (1:ncell)=zero
  do imat = 1,nmat
    ! Get stiffened gas EOS parameters
    g0=eos_params(imat,1); p0=eos_params(imat,2)
    a0=one/(g0-one); b0=p0*g0/(g0-one)
    ! p=(gamma-1)*e-gamma*pinf; e=beta+alpha*p
    do k = 1,ncell
      ! Update alpha_tot and beta_tot
        alpha_tot(k) = alpha_tot(k) + f(k,imat) * a0
        beta_tot (k) = beta_tot (k) + f(k,imat) * b0
    end do
  end do
  gamma_tot(1:ncell)=one/alpha_tot(1:ncell)+one
  pinf_tot (1:ncell)=beta_tot(1:ncell)/alpha_tot(1:ncell)/gamma_tot(1:ncell)
  ! Calculate the interal energy for given pressure
  do k = 1,ncell
    e(k) = alpha_tot(k) * q(k,npri) + beta_tot(k) 
  end do
  ! Calculate the bulk modulus
  do imat = 1,nmat
    ! Get stiffened gas EOS parameters
    g0=eos_params(imat,1); p0=eos_params(imat,2)
    a0=one/(g0-one); b0=p0*g0/(g0-one)
    ! p=(gamma-1)*e-gamma*pinf; e=beta+alpha*p
    do k = 1,ncell
      kappa_mat(k,imat) = MAX(g(k,imat) * smallc**2, g0  * (q(k,npri) + p0))
      kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
    end do
  end do
  kappa_hat(1:ncell)=one/kappa_hat(1:ncell)
  ! Calculate the speed of sound (old method)
  do k = 1,ncell
    c(k) = gamma_tot(k)*(q(k,npri)+pinf_tot(k))/q(k,1)
    c(k) = sqrt(max(c(k),smallc**2))
  end do
  ! Calculate the total speed of sound (new method)
  !   do k = 1,ncell
  !      c(k) = kappa_hat(k) / q(k,1)
  !      c(k) = sqrt(max(c(k),smallc**2))
  !   end do
end subroutine eosinv../patch/multimat/godunov_fine.f90
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine godunov_fine(ilevel)
  use amr_commons
  use hydro_commons
  implicit none
  integer::ilevel
  !--------------------------------------------------------------------------
  ! This routine is a wrapper to the second order Godunov solver.
  ! Small grids (2x2x2) are gathered from level ilevel and sent to the
  ! hydro solver. On entry, hydro variables are gathered from array uold.
  ! On exit, unew has been updated. 
  !--------------------------------------------------------------------------
  integer::i,ivar,igrid,ncache,ngrid
  integer,dimension(1:nvector),save::ind_grid

  if(numbtot(1,ilevel)==0)return
  if(verbose)write(*,111)ilevel

  ! Loop over active grids by vector sweeps
  ncache=active(ilevel)%ngrid
  do igrid=1,ncache,nvector
     ngrid=MIN(nvector,ncache-igrid+1)
     do i=1,ngrid
        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)
     end do
     call godfine1(ind_grid,ngrid,ilevel)
  end do
  do ivar=1,nvar                                      ! Reverse boundaries
     call make_virtual_reverse_dp(unew(1,ivar),ilevel)
  end do
  call make_virtual_reverse_dp(divu(1),ilevel)

111 format('   Entering godunov_fine for level ',i2)

end subroutine godunov_fine
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine set_unew(ilevel)
  use amr_commons
  use hydro_commons
  implicit none
  integer::ilevel
  !--------------------------------------------------------------------------
  ! This routine sets array unew to its initial value uold before calling
  ! the hydro scheme. unew is set to zero in virtual boundaries.
  !--------------------------------------------------------------------------
  integer::i,ivar,ind,icpu,iskip
  real(dp)::d,u,v,w,e

  if(numbtot(1,ilevel)==0)return
  if(verbose)write(*,111)ilevel

  ! Set unew to uold for myid cells
  do ind=1,twotondim
     iskip=ncoarse+(ind-1)*ngridmax
     do i=1,active(ilevel)%ngrid
        active(ilevel)%igrid(i)=active(ilevel)%igrid(i)+iskip
     end do
     do ivar=1,nvar
        do i=1,active(ilevel)%ngrid
           unew(active(ilevel)%igrid(i),ivar) = uold(active(ilevel)%igrid(i),ivar)
        end do
     end do
     do i=1,active(ilevel)%ngrid
        divu(active(ilevel)%igrid(i)) = 0.0
     end do
     do i=1,active(ilevel)%ngrid
        active(ilevel)%igrid(i)=active(ilevel)%igrid(i)-iskip
     end do
  end do

  ! Set unew to 0 for virtual boundary cells
  do icpu=1,ncpu
  do ind=1,twotondim
     iskip=ncoarse+(ind-1)*ngridmax
     do i=1,reception(icpu,ilevel)%ngrid
        reception(icpu,ilevel)%igrid(i)=reception(icpu,ilevel)%igrid(i)+iskip
     end do
     do ivar=1,nvar
        do i=1,reception(icpu,ilevel)%ngrid
           unew(reception(icpu,ilevel)%igrid(i),ivar)=0.0
        end do
     end do
     do i=1,reception(icpu,ilevel)%ngrid
        divu(reception(icpu,ilevel)%igrid(i)) = 0.0
     end do
     do i=1,reception(icpu,ilevel)%ngrid
        reception(icpu,ilevel)%igrid(i)=reception(icpu,ilevel)%igrid(i)-iskip
     end do
  end do
  end do

111 format('   Entering set_unew for level ',i2)

end subroutine set_unew
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine set_uold(ilevel)
  use amr_commons
  use hydro_commons
  implicit none
  integer::ilevel
  !--------------------------------------------------------------------------
  ! This routine sets array uold to its new value unew after the
  ! hydro step.
  !--------------------------------------------------------------------------
  integer::i,igrid,ngrid,ncache
  integer,dimension(1:nvector),save::ind_grid

  if(numbtot(1,ilevel)==0)return
  if(verbose)write(*,111)ilevel

  ! Update unew using non-conservative source terms
  ! and store result in uold

  ! Loop over active grids by vector sweeps
  ncache=active(ilevel)%ngrid
  do igrid=1,ncache,nvector
     ngrid=MIN(nvector,ncache-igrid+1)
     do i=1,ngrid
        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)
     end do
     call noncons1(ind_grid,ngrid,ilevel)
  end do

111 format('   Entering set_uold for level ',i2)

end subroutine set_uold
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine noncons1(ind_grid,ncache,ilevel)
  use amr_commons
  use hydro_commons
  use poisson_commons
  implicit none
  integer::ilevel,ncache
  integer,dimension(1:nvector)::ind_grid
  !-------------------------------------------------------------------
  ! Update volume fraction using compressibility source terms

  integer ,dimension(1:nvector),save::ind_cell
  integer ::i,ivar,imat,idim,ind,iskip
  logical ,dimension(1:nvector),save::body
  real(dp),dimension(1:nvector),save::pp,cc,ekin,kappa_hat
  real(dp),dimension(1:nvector,1:npri),save::qq
  real(dp),dimension(1:nvector,1:nmat),save::ff,gg,fg,kappa_mat
  real(dp)::g0,p0,a0,b0,df_over_f,rloc,skip_loc,dx,eps,scale,dx_loc
  real(dp)::one=1.0_dp, half=0.5_dp, zero=0.0_dp
  real(dp),dimension(1:8)::xc
  integer ::ix,iy,iz,nx_loc
  logical ::error

  dx=0.5d0**ilevel
  skip_loc=dble(icoarse_min)
  nx_loc=(icoarse_max-icoarse_min+1)
  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale

  ! Set position of cell centers relative to grid center
  do ind=1,twotondim
     iz=(ind-1)/4
     iy=(ind-1-4*iz)/2
     ix=(ind-1-2*iy-4*iz)
     xc(ind)=(dble(ix)-0.5D0)*dx
  end do
  
  ! Loop over cells
  do ind=1,twotondim
     iskip=ncoarse+(ind-1)*ngridmax
     do i=1,ncache
        ind_cell(i)=ind_grid(i)+iskip
     end do

     ! Volume fraction and fluid density
     do imat=1,nmat
        do i=1,ncache
           ff(i,imat)=uold(ind_cell(i),imat+npri)
           gg(i,imat)=uold(ind_cell(i),imat+npri+nmat)
        end do
     end do
     ! Total density
     do i=1,ncache
        qq(i,1)=uold(ind_cell(i),1)
     end do
     ! Specific kinetic energy
     ekin(1:ncache)=zero
     do idim=1,ndim
        do i=1,ncache
           qq(i,idim+1)=uold(ind_cell(i),idim+1)/qq(i,1)
           ekin(i)=ekin(i)+half*qq(i,idim+1)**2
        end do
     end do
     ! Total internal energy
     do i=1,ncache
        qq(i,npri)=uold(ind_cell(i),npri)-qq(i,1)*ekin(i)
     end do
     ! Pressure from eos
     call eos(ff,gg,qq,pp,cc,kappa_mat,kappa_hat,ncache)

     ! Source terms for fluid density (Godunov-like advection)
     do imat=1,nmat
        ivar=npri+nmat+imat
        do i=1,ncache
           ! Material compressibility
           df_over_f = kappa_hat(i)/kappa_mat(i,imat)

           ! Explicit time integration
!           unew(ind_cell(i),ivar)=unew(ind_cell(i),ivar) &
!                & +uold(ind_cell(i),ivar)*divu(ind_cell(i))*(df_over_f-one)

           ! Implicit time integration
           unew(ind_cell(i),ivar)=unew(ind_cell(i),ivar)/(1d0 &
                & - divu(ind_cell(i))*(df_over_f-one))

        end do
     end do
     ! Source terms for volume fraction (Godunov-like advection)
     do imat=1,nmat
        ivar=npri+imat
        do i=1,ncache
           ! No compressibility in volume fraction
           df_over_f  = one !kappa_hat(i)/kappa_mat(i,imat) 

           ! Explicit time integration
           unew(ind_cell(i),ivar)=unew(ind_cell(i),ivar) &
                & -uold(ind_cell(i),ivar)*divu(ind_cell(i))*df_over_f

           ! Implicit time integration
!           unew(ind_cell(i),ivar)=unew(ind_cell(i),ivar)/(1d0 &
!                & + divu(ind_cell(i))*df_over_f)

        end do
     end do

     if(static)then
        ! Embedded body is material #1
        do i=1,ncache
           body(i)= uold(ind_cell(i),npri+1) > 0.01
        end do
        do ivar=1,nvar
           do i=1,ncache
              if(.not. body(i))then
                 uold(ind_cell(i),ivar) = unew(ind_cell(i),ivar)
              endif
           end do
        end do
     else
        ! Store results in uold
        do ivar=1,nvar
           do i=1,ncache
              uold(ind_cell(i),ivar) = unew(ind_cell(i),ivar)
           end do
        end do
     end if

  end do
  ! End loop over cells

end subroutine noncons1
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine godfine1(ind_grid,ncache,ilevel)
  use amr_commons
  use hydro_commons
  use poisson_commons
  implicit none
  integer::ilevel,ncache
  integer,dimension(1:nvector)::ind_grid
  !-------------------------------------------------------------------
  ! This routine gathers first hydro variables from neighboring grids
  ! to set initial conditions in a 6x6x6 grid. It interpolate from
  ! coarser level missing grid variables. It then calls the
  ! Godunov solver that computes fluxes. These fluxes are zeroed at 
  ! coarse-fine boundaries, since contribution from finer levels has
  ! already been taken into account. Conservative variables are updated 
  ! and stored in array unew(:), both at the current level and at the 
  ! coarser level if necessary.
  !-------------------------------------------------------------------
  integer ,dimension(1:nvector,1:threetondim     ),save::nbors_father_cells
  integer ,dimension(1:nvector,1:twotondim       ),save::nbors_father_grids
  integer ,dimension(1:nvector,0:twondim         ),save::ibuffer_father
  real(dp),dimension(1:nvector,0:twondim  ,1:nvar),save::u1
  real(dp),dimension(1:nvector,0:twondim  ,1:ndim),save::g1
  real(dp),dimension(1:nvector,1:twotondim,1:nvar),save::u2
  real(dp),dimension(1:nvector,1:twotondim,1:ndim),save::g2

  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar),save::uloc
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:ndim),save::gloc
  real(dp),dimension(1:nvector,iu1:iu2),save::rloc,wloc_left,wloc_right
  real(dp),dimension(1:nvector,if1:if2,jf1:jf2,kf1:kf2,1:nvar,1:ndim),save::flux
  real(dp),dimension(1:nvector,if1:if2,jf1:jf2,kf1:kf2,1:2,1:ndim),save::tmp
  logical ,dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2),save::ok

  integer,dimension(1:nvector),save::igrid_nbor,ind_cell,ind_buffer
  logical,dimension(1:nvector),save::exist_nbor

  integer::i,j,ivar,idim,ind_son,ind_father,iskip,nbuffer,ibuffer,nx_loc
  integer::i0,j0,k0,i1,j1,k1,i2,j2,k2,i3,j3,k3
  integer::i1min,i1max,j1min,j1max,k1min,k1max
  integer::i2min,i2max,j2min,j2max,k2min,k2max
  integer::i3min,i3max,j3min,j3max,k3min,k3max
  real(dp)::dx,eps,scale,skip_loc,dx_loc

  ! Rescaling factors
  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=dble(icoarse_min)
  scale=boxlen/dble(nx_loc)

  ! Mesh spacing in that level
  dx=0.5D0**ilevel
  dx_loc=dx*scale

  ! Integer constants
  i1min=0; i1max=0; i2min=0; i2max=0; i3min=1; i3max=1
  j1min=0; j1max=0; j2min=0; j2max=0; j3min=1; j3max=1
  k1min=0; k1max=0; k2min=0; k2max=0; k3min=1; k3max=1
  if(ndim>0)then
     i1max=2; i2max=1; i3max=2
  end if
  if(ndim>1)then
     j1max=2; j2max=1; j3max=2
  end if
  if(ndim>2)then
     k1max=2; k2max=1; k3max=2
  end if

  !------------------------------------------
  ! Gather 3^ndim neighboring father cells
  !------------------------------------------
  do i=1,ncache
     ind_cell(i)=father(ind_grid(i))
  end do
  call get3cubefather(ind_cell,nbors_father_cells,nbors_father_grids,ncache,ilevel)
  
  !---------------------------
  ! Gather 6x6x6 cells stencil
  !---------------------------
  gloc=0.0d0
  ! Loop over 3x3x3 neighboring father cells
  do k1=k1min,k1max
  do j1=j1min,j1max
  do i1=i1min,i1max
     
     ! Check if neighboring grid exists
     ind_father=1+i1+3*j1+9*k1
     do i=1,ncache
        igrid_nbor(i)=son(nbors_father_cells(i,ind_father))
        exist_nbor(i)=igrid_nbor(i)>0
     end do
     
     ! If not, interpolate variables from parent cells
     nbuffer=0
     do i=1,ncache
        if(.not. exist_nbor(i))then
           nbuffer=nbuffer+1
           ind_buffer(nbuffer)=nbors_father_cells(i,ind_father)
        end if
     end do
     call getnborfather(ind_buffer,ibuffer_father,nbuffer,ilevel)
     do j=0,twondim
        do ivar=1,nvar
           do i=1,nbuffer
              u1(i,j,ivar)=uold(ibuffer_father(i,j),ivar)
           end do
        end do
     end do
     call interpol_hydro(u1,u2,nbuffer)
  
     ! Loop over 2x2x2 cells
     do k2=k2min,k2max
     do j2=j2min,j2max
     do i2=i2min,i2max

        ind_son=1+i2+2*j2+4*k2
        iskip=ncoarse+(ind_son-1)*ngridmax
        do i=1,ncache
           ind_cell(i)=iskip+igrid_nbor(i)
        end do
        
        i3=1; j3=1; k3=1
        if(ndim>0)i3=1+2*(i1-1)+i2
        if(ndim>1)j3=1+2*(j1-1)+j2
        if(ndim>2)k3=1+2*(k1-1)+k2
        
        ! Gather hydro variables
        do ivar=1,nvar
           ibuffer=0
           do i=1,ncache
              if(exist_nbor(i))then
                 uloc(i,i3,j3,k3,ivar)=uold(ind_cell(i),ivar)
              else
                 ibuffer=ibuffer+1
                 uloc(i,i3,j3,k3,ivar)=u2(ibuffer,ind_son,ivar)
              end if
           end do
        end do
        
        ! Gather gravitational acceleration
        if(poisson)then
           do idim=1,ndim
              ibuffer=0
              do i=1,ncache
                 if(exist_nbor(i))then
                    gloc(i,i3,j3,k3,idim)=f(ind_cell(i),idim)
                 else
                    ibuffer=ibuffer+1
                    gloc(i,i3,j3,k3,idim)=f(ibuffer_father(ibuffer,0),idim)
                 end if
              end do
           end do
        end if
        
        ! Gather refinement flag
        do i=1,ncache
           if(exist_nbor(i))then
              ok(i,i3,j3,k3)=son(ind_cell(i))>0
           else
              ok(i,i3,j3,k3)=.false.
           end if
        end do
        
     end do
     end do
     end do
     ! End loop over cells

  end do
  end do
  end do
  ! End loop over neighboring grids

  !-----------------------
  ! Compute cell radii
  !-----------------------
  do i3=iu1,iu2
     do i=1,ncache
        rloc(i,i3)=(xg(ind_grid(i),1)-skip_loc+(dble(i3+1)-2.5d0)*dx)*scale
     end do
  end do
  
  !---------------------------------------------------------
  ! Compute left and right interface geometrical weighting
  !---------------------------------------------------------
  do i3=iu1,iu2
     if(geom==3)then
        do i=1,ncache
           eps=dx_loc/rloc(i,i3)/2.0
           wloc_left (i,i3)=(1.0-eps)**2/(1.0+eps**2/3.0)
           wloc_right(i,i3)=(1.0+eps)**2/(1.0+eps**2/3.0)
        end do
     else if (geom==2) then
        do i=1,ncache
           eps=dx_loc/rloc(i,i3)/2.0
           wloc_left (i,i3)=1.0-eps
           wloc_right(i,i3)=1.0+eps
        end do
     else
        do i=1,ncache
           wloc_left (i,i3)=1.0
           wloc_right(i,i3)=1.0
        end do
     endif
  end do

  !-----------------------------------------------
  ! Compute flux using second-order Godunov method
  !-----------------------------------------------
  flux=0.0d0; tmp=0.0d0
  call unsplit(uloc,gloc,rloc,flux,tmp,dx_loc,dx_loc,dx_loc,dtnew(ilevel),ncache)

  !------------------------------------------------
  ! Reset flux along direction at refined interface    
  !------------------------------------------------
  do idim=1,ndim
     i0=0; j0=0; k0=0
     if(idim==1)i0=1
     if(idim==2)j0=1
     if(idim==3)k0=1
     do k3=k3min,k3max+k0
     do j3=j3min,j3max+j0
     do i3=i3min,i3max+i0
        do ivar=1,nvar
           do i=1,ncache
              if(ok(i,i3-i0,j3-j0,k3-k0) .or. ok(i,i3,j3,k3))then
                 flux(i,i3,j3,k3,ivar,idim)=0.0d0
              end if
           end do
        end do
        do ivar=1,2
           do i=1,ncache
              if(ok(i,i3-i0,j3-j0,k3-k0) .or. ok(i,i3,j3,k3))then
                 tmp (i,i3,j3,k3,ivar,idim)=0.0d0
              end if
           end do
        end do
     end do
     end do
     end do
  end do
  !--------------------------------------
  ! Conservative update at level ilevel
  !--------------------------------------
  do idim=1,ndim
     i0=0; j0=0; k0=0
     if(idim==1)i0=1
     if(idim==2)j0=1
     if(idim==3)k0=1
     do k2=k2min,k2max
     do j2=j2min,j2max
     do i2=i2min,i2max
        ind_son=1+i2+2*j2+4*k2
        iskip=ncoarse+(ind_son-1)*ngridmax
        do i=1,ncache
           ind_cell(i)=iskip+ind_grid(i)
        end do
        i3=1+i2
        j3=1+j2
        k3=1+k2
        ! Update conservative variables new state vector and velocity divergence
        if(geom>1.and.idim==1)then
           ! Use geometrical weighting
           do ivar=1,nvar
              do i=1,ncache
                 unew(ind_cell(i),ivar) = unew(ind_cell(i),ivar) + &
                      & (flux(i,i3   ,j3   ,k3   ,ivar,idim)*wloc_left (i,i3) &
                      & -flux(i,i3+i0,j3+j0,k3+k0,ivar,idim)*wloc_right(i,i3))
              end do
           end do
           do i=1,ncache
              divu(ind_cell(i))=divu(ind_cell(i))+ &
                   & (tmp(i,i3   ,j3   ,k3   ,1,idim)*wloc_left (i,i3) &
                   & -tmp(i,i3+i0,j3+j0,k3+k0,1,idim)*wloc_right(i,i3))
           end do
           ! Add -grad(P) term for radial momentum
           do i=1,ncache
              unew(ind_cell(i),2) = unew(ind_cell(i),2) + &
                   & (tmp (i,i3   ,j3   ,k3   ,2,idim) &
                   & -tmp (i,i3+i0,j3+j0,k3+k0,2,idim))
           end do
        else
           do ivar=1,nvar
              do i=1,ncache
                 unew(ind_cell(i),ivar)=unew(ind_cell(i),ivar)+ &
                      & (flux(i,i3   ,j3   ,k3   ,ivar,idim) &
                      & -flux(i,i3+i0,j3+j0,k3+k0,ivar,idim))
              end do
           end do
           ! Update velocity divergence
           do i=1,ncache
              divu(ind_cell(i))=divu(ind_cell(i))+ &
                   & (tmp(i,i3   ,j3   ,k3   ,1,idim) &
                   & -tmp(i,i3+i0,j3+j0,k3+k0,1,idim))
           end do
        endif
     end do
     end do
     end do
  end do

  !--------------------------------------
  ! Conservative update at level ilevel-1
  !--------------------------------------
  ! Loop over dimensions
  do idim=1,ndim
     i0=0; j0=0; k0=0
     if(idim==1)i0=1
     if(idim==2)j0=1
     if(idim==3)k0=1
     
     !----------------------
     ! Left flux at boundary
     !----------------------     
     ! Check if grids sits near left boundary
     do i=1,ncache
        exist_nbor(i)=son(nbor(ind_grid(i),2*idim-1))>0
     end do
     ! Gather neighbor father cells index
     do i=1,ncache
        ind_buffer(i)=nbor(ind_grid(i),2*idim-1)
     end do
     ! Conservative update of new state variables
     do ivar=1,nvar
        ! Loop over boundary cells
        do k3=k3min,k3max-k0
        do j3=j3min,j3max-j0
        do i3=i3min,i3max-i0
           do i=1,ncache
              if(.not.exist_nbor(i))then
                 unew(ind_buffer(i),ivar)=unew(ind_buffer(i),ivar) &
                      & -flux(i,i3,j3,k3,ivar,idim)/dble(twotondim)
              end if
           end do
        end do
        end do
        end do
     end do
     ! Update velocity divergence
     do k3=k3min,k3max-k0
     do j3=j3min,j3max-j0
     do i3=i3min,i3max-i0
        do i=1,ncache
           if(.not.exist_nbor(i))then
              divu(ind_buffer(i))=divu(ind_buffer(i)) &
                   & -tmp(i,i3,j3,k3,1,idim)/dble(twotondim)
           end if
        end do
     end do
     end do
     end do
     
     !-----------------------
     ! Right flux at boundary
     !-----------------------     
     ! Check if grids sits near right boundary
     do i=1,ncache
        exist_nbor(i)=son(nbor(ind_grid(i),2*idim))>0
     end do
     ! Gather buffer indices
     do i=1,ncache
        ind_buffer(i)=nbor(ind_grid(i),2*idim)
     end do
     ! Conservative update of new state variables
     do ivar=1,nvar
        ! Loop over boundary cells
        do k3=k3min+k0,k3max
        do j3=j3min+j0,j3max
        do i3=i3min+i0,i3max
           do i=1,ncache
              if(.not.exist_nbor(i))then
                 unew(ind_buffer(i),ivar)=unew(ind_buffer(i),ivar) &
                      & +flux(i,i3+i0,j3+j0,k3+k0,ivar,idim)/dble(twotondim)
              end if
           end do
        end do
        end do
        end do
     end do
     ! Update velocity divergence
     do k3=k3min+k0,k3max
     do j3=j3min+j0,j3max
     do i3=i3min+i0,i3max
        do i=1,ncache
           if(.not.exist_nbor(i))then
              divu(ind_buffer(i))=divu(ind_buffer(i)) &
                   & +tmp(i,i3+i0,j3+j0,k3+k0,1,idim)/dble(twotondim)
           end if
        end do
     end do
     end do
     end do

  end do
  ! End loop over dimensions

end subroutine godfine1
../patch/multimat/godunov_utils.f90
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine eos(f,g,q,p,c,kappa_mat,kappa_hat,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  integer::ncell
  real(dp),dimension(1:nvector,1:nmat)::f,g,kappa_mat
  real(dp),dimension(1:nvector,1:npri)::q
  real(dp),dimension(1:nvector)::p,c,kappa_hat 
  ! Compute total pressure and sound speed from total internal energy
  ! On entry:
  ! f is the volume fraction of each fluid
  ! g is the true density of each fluid
  ! q are the total primitive variables (d, u, eint)
  ! On exit:
  ! p is the total pressure
  ! c is the total sound speed
  integer::k,imat
  real(dp)::g0,p0,a0,b0
  real(dp),dimension(1:nvector),save::alpha_tot,beta_tot
  real(dp),dimension(1:nvector),save::gamma_tot,pinf_tot
  real(dp)::smallgamma,biggamma,e_0,e_c,P_c, delpc
  real(dp)::rho_0,C_v,T_0,E_1,E_2,A_1,A_2
  real(dp),dimension(1:nvector),save::ec_hat,pc_hat, alpha_hat
  real(dp),dimension(1:nvector),save::gamma_hat,delpc_hat

  if(eos_name == 'stiffened gas')then       
      ! Initialize variables as zero and update them iteratively
      alpha_tot(1:ncell)=zero
      beta_tot (1:ncell)=zero
      do imat = 1,nmat
      ! Get stiffened gas EOS parameters
      g0=eos_params(imat,1); p0=eos_params(imat,2)
      a0=one/(g0-one); b0=p0*g0/(g0-one)
      ! p=(gamma-1)*e-gamma*pinf; e=beta+alpha*p
         do k = 1,ncell
            ! Update alpha_tot and beta_tot
            alpha_tot(k) = alpha_tot(k) + f(k,imat) * a0
            beta_tot (k) = beta_tot (k) + f(k,imat) * b0
         end do
      end do
      gamma_tot(1:ncell)=one/alpha_tot(1:ncell)+one
      pinf_tot (1:ncell)=beta_tot(1:ncell)/alpha_tot(1:ncell)/gamma_tot(1:ncell)
      ! Calculate the pressure for given internal energy
      do k = 1,ncell
         p(k) = (q(k,npri) - beta_tot(k)) / alpha_tot(k)
      end do
      ! Calculate the bulk modulus
      do imat = 1,nmat
         ! Get stiffened gas EOS parameters
         g0=eos_params(imat,1); p0=eos_params(imat,2)
         a0=one/(g0-one); b0=p0*g0/(g0-one)
         ! p=(gamma-1)*e-gamma*pinf; e=beta+alpha*p
         do k = 1,ncell
            kappa_mat(k,imat) = MAX(max(g(k,imat),smallr) * smallc**2, g0  * (p(k) + p0))
            kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
         end do
      end do
      kappa_hat(1:ncell)=one/kappa_hat(1:ncell)
      ! Calculate the speed of sound (old method)
      do k = 1,ncell
         c(k) = gamma_tot(k)*(p(k)+pinf_tot(k))/q(k,1)
         c(k) = sqrt(max(c(k),smallc**2))
      end do
      ! Calculate the total speed of sound (new method)
      ! do k = 1,ncell
      !    c(k) = kappa_hat(k) / q(k,1)
      !    c(k) = sqrt(max(c(k),smallc**2))
      ! end do   

   else if(eos_name == 'mie-grueneisen')then
      kappa_hat(1:ncell)=zero
      alpha_hat(1:ncell)=zero
      pc_hat (1:ncell)=zero
      ec_hat(1:ncell)=zero
      delpc_hat(1:ncell)=zero
      gamma_hat(1:ncell)=zero
      ! Mie-Gruneisen implementation trial
      do imat = 1,nmat
         ! Get Mie-Grueneisen EOS parameters
         smallgamma=eos_params(imat,1);biggamma=eos_params(imat,2);e_0=eos_params(imat,3);rho_0=eos_params(imat,4)
         ! Test case for checking whether the model works
         ! smallgamma=eos_params(imat,1); biggamma=0 ; p0=eos_params(imat,2)
         ! e_0 =  p0
         ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
         a0 = one / (smallgamma-one) 
         do k = 1,ncell
            ! Update Mie-Gruneisen terms for each material
            ! print *, g(k,imat)
            e_c = e_0 * (max(g(k,imat),smallr)/rho_0)**biggamma
            P_c = e_0 * (biggamma-one) * (max(g(k,imat),smallr)/rho_0)**biggamma
            delpc = (e_0/rho_0) * biggamma * (biggamma-one) * (max(g(k,imat),smallr)/rho_0)**(biggamma-one)
            ! Update total values
            alpha_hat(k) = alpha_hat(k) + f(k,imat) * a0
            ec_hat(k) = ec_hat(k) + f(k,imat) * e_c
            pc_hat(k) = pc_hat(k) + f(k,imat) * P_c * a0 
            delpc_hat(k) = delpc_hat(k) + f(k,imat) * delpc * a0 
         end do
      end do
      pc_hat(1:ncell) = pc_hat(1:ncell)/alpha_hat(1:ncell)
      delpc_hat(1:ncell) = delpc_hat(1:ncell)/alpha_hat(1:ncell)
      gamma_hat(1:ncell)=one/alpha_hat(1:ncell)+one
      do k = 1,ncell
         ! Calculate the pressure for given internal energy
         p(k) = max(q(k,npri) - ec_hat(k),0.0) / alpha_hat(k) + pc_hat(k)
      end do 

      do imat = 1,nmat
         smallgamma=eos_params(imat,1);biggamma=eos_params(imat,2);e_0=eos_params(imat,3);rho_0=eos_params(imat,4)
         ! smallgamma=eos_params(imat,1); biggamma=0 ; p0=eos_params(imat,2)
         ! e_0 =  p0
         ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
         a0 = one / (smallgamma-one) 
         do k = 1,ncell
            ! Calculate the bulk moduli
            ! c_mat**2 = P_c' + smallgamma/rho * (P-P_c)
            P_c = e_0 * (biggamma-one) * (max(g(k,imat),smallr)/rho_0)**biggamma
            delpc = (e_0/rho_0) * biggamma * (biggamma-one) * (max(g(k,imat),smallr)/rho_0)**(biggamma-one)
            kappa_mat(k,imat) = max(g(k,imat),smallr) * max(smallc**2,delpc+(smallgamma/max(g(k,imat),smallr))*max(p(k)-P_c,0.0))
            kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
         end do
      end do
      ! We have calculated 1/kappa_hat so we invert it
      kappa_hat(1:ncell) = one / kappa_hat(1:ncell)
      ! Calculate the speed of sound (old method)
      do k = 1,ncell
      c(k) = delpc_hat(k)+(gamma_hat(k)/max(q(k,1),smallr)*max(p(k)-pc_hat(k),0.0))
      c(k) = sqrt(max(c(k),smallc**2))
      end do
      ! Calculate the total speed of sound(new method)
      ! do k = 1,ncell 
      !    c(k) = kappa_hat(k) / q(k,1)
      !    c(k) = sqrt(max(c(k),smallc**2))
      ! end do

   else if(eos_name == 'cochran-chan')then
      kappa_hat(1:ncell)=zero
      alpha_hat(1:ncell)=zero
      pc_hat (1:ncell)=zero
      ec_hat(1:ncell)=zero
      delpc_hat(1:ncell)=zero
      gamma_hat(1:ncell)=zero
      ! Cochran-Chan EOS written in terms of the Mie-Grueneisen EOS 
      do imat = 1,nmat
         ! Get Mie-Grueneisen EOS parameters
         rho_0=eos_params(imat,1);C_v=eos_params(imat,2);T_0=eos_params(imat,3)
         E_1=eos_params(imat,4);E_2=eos_params(imat,5);A_1=eos_params(imat,6);A_2=eos_params(imat,7)
         smallgamma=eos_params(imat,8)
         ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
         a0 = one / (smallgamma-one) 
         do k = 1,ncell
            ! Update Mie-Gruneisen terms for each material
            e_c = -A_1 / (rho_0*(1. - E_1))  * (((rho_0/(max(g(k,imat),smallr)))**(1.-E_1))-1.) + A_2 / (rho_0*(1. - E_2)) * (((rho_0/(max(g(k,imat),smallr)))**(1.-E_2))-1.) - C_v * T_0
            P_c = A_1 * (rho_0/(max(g(k,imat),smallr)))**(-E_1) - A_2 * (rho_0/(max(g(k,imat),smallr)))**(-E_2)
            delpc = A_1 * E_1 * ((max(g(k,imat),smallr))**(E_1-1)/rho_0**E_1) - A_2 * E_2 * ((max(g(k,imat),smallr))**(E_2-1)/rho_0**E_2)
            ! Update total values
            alpha_hat(k) = alpha_hat(k) + f(k,imat) * a0
            ec_hat(k) = ec_hat(k) + f(k,imat) * e_c
            pc_hat(k) = pc_hat(k) + (f(k,imat)*a0*P_c) 
            delpc_hat(k) = delpc_hat(k) + (f(k,imat)*a0*delpc) 
         end do
      end do
      pc_hat(1:ncell) = pc_hat(1:ncell)/alpha_hat(1:ncell)
      delpc_hat(1:ncell) = delpc_hat(1:ncell)/alpha_hat(1:ncell)
      gamma_hat(1:ncell) = one/alpha_hat(1:ncell)+one
      do k = 1,ncell
         ! Calculate the pressure for given internal energy
         p(k) = max(q(k,npri) - ec_hat(k),0.0) / alpha_hat(k) + pc_hat(k)
      end do 

      do imat = 1,nmat
         rho_0=eos_params(imat,1);C_v=eos_params(imat,2);T_0=eos_params(imat,3)
         E_1=eos_params(imat,4);E_2=eos_params(imat,5);A_1=eos_params(imat,6);A_2=eos_params(imat,7)
         smallgamma=eos_params(imat,8)
         ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
         a0 = one / (smallgamma-one) 
         do k = 1,ncell
            ! Calculate the bulk moduli
            ! c_mat**2 = P_c' + smallgamma/rho * (P-P_c)
            P_c = A_1 * (rho_0/g(k,imat))**(-E_1) - A_2 * (rho_0/g(k,imat))**(-E_2)
            delpc = A_1 * E_1 * (g(k,imat)**(E_1-1)/rho_0**E_1) - A_2 * E_2 * (g(k,imat)**(E_2-1)/rho_0**E_2)
            kappa_mat(k,imat) = max(g(k,imat),smallr) * MAX(smallc**2, delpc+(smallgamma/(max(g(k,imat),smallr)))*max(p(k)-P_c,0.0))
            kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
         end do
      end do
      ! We have calculated 1/kappa_hat so we invert it
      kappa_hat(1:ncell) = one / kappa_hat(1:ncell)
      ! Calculate the speed of sound (old method)
      do k = 1,ncell
      c(k) = delpc_hat(k)+(gamma_hat(k)/q(k,1))*max(p(k)-pc_hat(k),0.0)
      c(k) = sqrt(max(c(k),smallc**2))
      end do
      ! Calculate the total speed of sound(new method)
      ! do k = 1,ncell 
      !    c(k) = kappa_hat(k) / q(k,1)
      !    c(k) = sqrt(max(c(k),smallc**2))
      ! end do
   end if
end subroutine eos

!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine eosinv(f,g,q,e,c,kappa_mat,kappa_hat,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  integer::ncell
  real(dp),dimension(1:nvector,1:nmat)::f,g,c_mat,kappa_mat
  real(dp),dimension(1:nvector,1:npri)::q
  real(dp),dimension(1:nvector)::e,c,kappa_hat
  ! Compute total internal energy and sound speed from total pressure
  ! On entry:
  ! f is the volume fraction of each fluid
  ! g is the true density of each fluid
  ! q are the total primitive variables (d, u, P)
  ! On exit:
  ! eint is the total internal energy
  ! c is the sound speed of each fluid 
  ! c_hat is the total sound speed
  integer::k,imat
  real(dp)::g0,p0,a0,b0
  real(dp),dimension(1:nvector),save::alpha_tot,beta_tot
  real(dp),dimension(1:nvector),save::gamma_tot,pinf_tot
  real(dp)::smallgamma,biggamma,e_0,e_c,P_c, delpc
  real(dp)::rho_0,C_v,T_0,E_1,E_2,A_1,A_2
  real(dp),dimension(1:nvector),save::ec_hat,pc_hat, alpha_hat
  real(dp),dimension(1:nvector),save::gamma_hat,delpc_hat

   if(eos_name=='stiffened gas')then 
      ! Initialize variables as zero and update them iteratively
      alpha_tot(1:ncell)=zero
      beta_tot (1:ncell)=zero
     do imat = 1,nmat
        ! Get stiffened gas EOS parameters
        g0=eos_params(imat,1); p0=eos_params(imat,2)
        a0=one/(g0-one); b0=p0*g0/(g0-one)
        ! p=(gamma-1)*e-gamma*pinf; e=beta+alpha*p
        do k = 1,ncell
           ! Update alpha_tot and beta_tot
           alpha_tot(k) = alpha_tot(k) + f(k,imat) * a0
           beta_tot (k) = beta_tot (k) + f(k,imat) * b0
        end do
     end do
     gamma_tot(1:ncell)=one/alpha_tot(1:ncell)+one
     pinf_tot (1:ncell)=beta_tot(1:ncell)/alpha_tot(1:ncell)/gamma_tot(1:ncell)
     ! Calculate the interal energy for given pressure
     do k = 1,ncell
        e(k) = alpha_tot(k) * q(k,npri) + beta_tot(k) 
     end do
     ! Calculate the bulk modulus
     do imat = 1,nmat
        ! Get stiffened gas EOS parameters
        g0=eos_params(imat,1); p0=eos_params(imat,2)
        a0=one/(g0-one); b0=p0*g0/(g0-one)
        ! p=(gamma-1)*e-gamma*pinf; e=beta+alpha*p
        do k = 1,ncell
           kappa_mat(k,imat) = MAX(max(g(k,imat),smallr) * smallc**2, g0  * (q(k,npri) + p0))
           kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
        end do
     end do
     kappa_hat(1:ncell)=one/kappa_hat(1:ncell)
     ! Calculate the speed of sound (old method)
     do k = 1,ncell
        c(k) = gamma_tot(k)*(q(k,npri)+pinf_tot(k))/q(k,1)
        c(k) = sqrt(max(c(k),smallc**2))
     end do
      ! Calculate the total speed of sound (new method)
   !   do k = 1,ncell
   !      c(k) = kappa_hat(k) / q(k,1)
   !      c(k) = sqrt(max(c(k),smallc**2))
   !   end do

   else if(eos_name=='mie-grueneisen')then
      kappa_hat(1:ncell)=zero
      alpha_hat(1:ncell)=zero
      pc_hat (1:ncell)=zero
      ec_hat(1:ncell)=zero
      delpc_hat(1:ncell)=zero
      gamma_hat(1:ncell)=zero
      ! Mie-Gruneisen implementation trial
      do imat = 1,nmat
         ! Get Mie-Grueneisen EOS parameters
         smallgamma=eos_params(imat,1);biggamma=eos_params(imat,2);e_0=eos_params(imat,3);rho_0=eos_params(imat,4)
         ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
         ! Test case for checking whether the model works
         ! smallgamma=eos_params(imat,1); biggamma=0 ; p0=eos_params(imat,2)
         ! e_0 =  p0
         ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
         a0 = one / (smallgamma-one) 
         do k = 1,ncell
            ! Update Mie-Gruneisen terms for each material
            e_c = e_0 * (max(g(k,imat),smallr)/rho_0)**biggamma
            P_c = e_0 * (biggamma-one) * (max(g(k,imat),smallr)/rho_0)**biggamma
            delpc = (e_0/rho_0) * biggamma * (biggamma-one) * (max(g(k,imat),smallr)/rho_0)**(biggamma-one)
            ! Update total values
            alpha_hat(k) = alpha_hat(k) + f(k,imat) * a0
            ec_hat(k) = ec_hat(k) + f(k,imat) * e_c
            pc_hat(k) = pc_hat(k) + f(k,imat) * P_c * a0 
            delpc_hat(k) = delpc_hat(k) + f(k,imat) * delpc * a0 
         end do
      end do
      pc_hat(1:ncell) = pc_hat(1:ncell)/alpha_hat(1:ncell)
      delpc_hat(1:ncell) = delpc_hat(1:ncell)/alpha_hat(1:ncell)
      gamma_hat(1:ncell) = one/alpha_hat(1:ncell)+one
      ! Calculate the internal energy for given pressure
      do k=1,ncell
         e(k) = alpha_hat(k) * max(q(k,npri)-pc_hat(k),0.0) + ec_hat(k)
      end do
      
      do imat = 1,nmat
         smallgamma=eos_params(imat,1);biggamma=eos_params(imat,2);e_0=eos_params(imat,3);rho_0=eos_params(imat,4)
         ! smallgamma=eos_params(imat,1); biggamma=0 ; p0=eos_params(imat,2)
         ! e_0 =  p0
         ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
         a0 = one / (smallgamma-one) 
         do k = 1,ncell
            ! Calculate the bulk moduli
            ! ! c_mat**2 = P_c' + smallgamma/rho * (P-P_c)
            P_c = e_0 * (biggamma-one) * (max(g(k,imat),smallr)/rho_0)**biggamma
            delpc = (e_0/rho_0) * biggamma * (biggamma-one) * (max(g(k,imat),smallr)/rho_0)**(biggamma-one)
            kappa_mat(k,imat) = g(k,imat) * MAX(smallc**2, delpc+(smallgamma/max(g(k,imat),smallr))*max(q(k,npri)-P_c,0.0))
            kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
         end do
      end do
      ! We have calculated 1/kappa_hat so we invert it
      kappa_hat(1:ncell) = one / kappa_hat(1:ncell)
      ! Calculate the speed of sound (old method)
      do k = 1,ncell
      c(k) = delpc_hat(k)+(gamma_hat(k)/q(k,1))*max(q(k,npri)-pc_hat(k),0.0)
      c(k) = sqrt(max(c(k),smallc**2))
      end do
      ! Calculate the total speed of sound (new method)
      ! do k = 1,ncell 
      !    c(k) = kappa_hat(k) / q(k,1)
      !    c(k) = sqrt(max(c(k),smallc**2))
      ! end do

   else if(eos_name == 'cochran-chan')then
      kappa_hat(1:ncell)=zero
      alpha_hat(1:ncell)=zero
      pc_hat (1:ncell)=zero
      ec_hat(1:ncell)=zero
      delpc_hat(1:ncell)=zero
      gamma_hat(1:ncell)=zero
      ! Cochran-Chan EOS written in terms of the Mie-Grueneisen EOS 
      do imat = 1,nmat
         ! Get Mie-Grueneisen EOS parameters
         rho_0=eos_params(imat,1);C_v=eos_params(imat,2);T_0=eos_params(imat,3)
         E_1=eos_params(imat,4);E_2=eos_params(imat,5);A_1=eos_params(imat,6);A_2=eos_params(imat,7)
         smallgamma=eos_params(imat,8)
         ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
         a0 = one / (smallgamma-one) 
         do k = 1,ncell
            ! Update Mie-Gruneisen terms for each material
            e_c = -A_1 / (rho_0*(1. - E_1))  * (((rho_0/(max(g(k,imat),smallr)))**(1.-E_1))-1.) + A_2 / (rho_0*(1. - E_2)) * (((rho_0/(max(g(k,imat),smallr)))**(1.-E_2))-1.) - C_v * T_0
            P_c = A_1 * (rho_0/(max(g(k,imat),smallr)))**(-E_1) - A_2 * (rho_0/(max(g(k,imat),smallr)))**(-E_2)
            delpc = A_1 * E_1 * ((max(g(k,imat),smallr))**(E_1-1)/rho_0**E_1) - A_2 * E_2 * ((max(g(k,imat),smallr))**(E_2-1)/rho_0**E_2)
            ! Update total values
            alpha_hat(k) = alpha_hat(k) + f(k,imat) * a0
            ec_hat(k) = ec_hat(k) + f(k,imat) * e_c
            pc_hat(k) = pc_hat(k) + (f(k,imat)*a0*P_c) 
            delpc_hat(k) = delpc_hat(k) + (f(k,imat)*a0*delpc) 
         end do
      end do
      pc_hat(1:ncell) = pc_hat(1:ncell)/alpha_hat(1:ncell)
      delpc_hat(1:ncell) = delpc_hat(1:ncell)/alpha_hat(1:ncell)
      gamma_hat(1:ncell)=one/alpha_hat(1:ncell)+one
      ! Calculate the internal energy for given pressure
      do k=1,ncell
         e(k) = alpha_hat(k) * (q(k,npri)-pc_hat(k)) + ec_hat(k)
      end do
      
      do imat = 1,nmat
         rho_0=eos_params(imat,1);C_v=eos_params(imat,2);T_0=eos_params(imat,3)
         E_1=eos_params(imat,4);E_2=eos_params(imat,5);A_1=eos_params(imat,6);A_2=eos_params(imat,7)
         smallgamma=eos_params(imat,8)
         ! P - P_c = (gamma - one) * (e - e_c) ; e = P/(gamma-1) + (e_c-P_c/(gamma-1))
         a0 = one / (smallgamma-one) 
         do k = 1,ncell
            ! Calculate the bulk moduli
            ! c_mat**2 = P_c' + smallgamma/rho * (P-P_c)
            P_c = A_1 * (rho_0/g(k,imat))**(-E_1) - A_2 * (rho_0/g(k,imat))**(-E_2)
            delpc = A_1 * E_1 * (g(k,imat)**(E_1-1)/rho_0**E_1) - A_2 * E_2 * (g(k,imat)**(E_2-1)/rho_0**E_2)
            kappa_mat(k,imat) = (max(g(k,imat),smallr)) * MAX(smallc**2, delpc+(smallgamma/(max(g(k,imat),smallr)))*max(q(k,npri)-P_c,0.0))
            kappa_hat(k) = kappa_hat(k) + f(k,imat) / kappa_mat(k,imat)
         end do
      end do
      ! We have calculated 1/kappa_hat so we invert it
      kappa_hat(1:ncell) = one / kappa_hat(1:ncell)
      ! Calculate the speed of sound (old method)
      do k = 1,ncell
      c(k) = delpc_hat(k)+(gamma_hat(k)/q(k,1))*max(q(k,npri)-pc_hat(k),0.0)
      c(k) = sqrt(max(c(k),smallc**2))
      end do
      ! Calculate the total speed of sound (new method)
      ! do k = 1,ncell 
      !    c(k) = kappa_hat(k) / q(k,1)
      !    c(k) = sqrt(max(c(k),smallc**2))
      ! end do
   end if
end subroutine eosinv

!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine cmpdt(uu,grav,rr,dx,dt,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  integer::ncell
  real(dp)::dx,dt
  real(dp),dimension(1:nvector,1:nvar)::uu
  real(dp),dimension(1:nvector,1:ndim)::grav
  real(dp),dimension(1:nvector)::rr
  
  real(dp),dimension(1:nvector,1:npri),save::qq
  real(dp),dimension(1:nvector,1:nmat),save::ff,gg,kappa_matt
  real(dp),dimension(1:nvector),save::ekin,dtot,cc,st,pp,kappa_hatt
  real(dp)::dtcell,eps
  integer::k,idim,imat

  ! Convert to primitive variable
     
  ! Volume fraction and fluid density
  do imat = 1,nmat
     do k = 1,ncell
        ff(k,imat) = uu(k,imat+npri)
        gg(k,imat) = uu(k,imat+npri+nmat)
     end do
  end do
     
  ! Compute density
  do k = 1,ncell
     qq(k,1) = uu(k,1)
  end do
  
  ! Compute velocity and specific kinetic energy
  ekin(1:ncell)=0.0
  do idim = 1,ndim
     do k = 1,ncell
        qq(k,idim+1) = uu(k,idim+1)/uu(k,1)
        ekin(k) = ekin(k) + half*qq(k,idim+1)**2
     end do
  end do
  
  ! Compute total internal energy
  do k = 1,ncell
     qq(k,npri) = uu(k,npri) - uu(k,1)*ekin(k)
  end do
  
  ! Call eos routine
  call eos(ff,gg,qq,pp,cc,kappa_matt,kappa_hatt,ncell)
  
  ! Compute wave speed
  if(geom==3)then
     do k = 1,ncell
        eps = dx/two/rr(k)
        cc(k) = (abs(qq(k,2))+cc(k))*(one+eps)**2/(one+third*eps**2)
     end do
  else if(geom==2)then
     do k = 1,ncell
        eps = dx/two/rr(k)
        cc(k) = (abs(qq(k,2))+cc(k))*(one+eps)
     end do
  else
     do k = 1,ncell
        cc(k) = abs(qq(k,2))+cc(k)
     end do
  endif
  do idim = 2,ndim
     do k = 1,ncell 
        cc(k) = cc(k) + abs(qq(k,idim+1))+cc(k)
     end do
  end do

  ! Compute gravity strength ratio
  do k = 1,ncell
     st(k) = zero
  end do
  do idim = 1,ndim
     do k = 1,ncell 
        st(k) = st(k) + abs(grav(k,idim))
     end do
  end do
  do k = 1,ncell
     st(k) = st(k)*dx/cc(k)**2
     st(k) = MAX(st(k),0.0001_dp)
  end do

  ! Compute maximum time step for each authorized cell
  dt = courant_factor*dx/smallc
  do k = 1,ncell
     dtcell = dx/cc(k)*(sqrt(one+two*courant_factor*st(k))-one)/st(k)
     dt = min(dt,dtcell)
  end do

end subroutine cmpdt
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine hydro_refine(ug,um,ud,ok,current_dim,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  ! dummy arguments
  integer::ncell,current_dim
  real(dp),dimension(1:nvector,1:nvar)::ug,um,ud
  logical ,dimension(1:nvector)       ::ok
  
  integer::k,idim,imat
  real(dp),dimension(1:nvector,1:npri),save::qg,qm,qd
  real(dp),dimension(1:nvector,1:nmat),save::fg,fm,fd
  real(dp),dimension(1:nvector,1:nmat),save::gg,gm,gd
  real(dp),dimension(1:nvector,1:nmat),save::kappa_matg,kappa_matm,kappa_matd
  real(dp),dimension(1:nvector),save::eking,ekinm,ekind
  real(dp),dimension(1:nvector),save::pg,pm,pd
  real(dp),dimension(1:nvector),save::cg,cm,cd
  real(dp),dimension(1:nvector),save::kappa_hatg,kappa_hatm,kappa_hatd
  logical ,dimension(1:nvector),save::wg,wd,bg,bm,bd
  real(dp)::ffg,ffm,ffd,ddg,ddm,ddd
  real(dp)::ppg,ppm,ppd,vvg,vvm,vvd
  real(dp)::ccg,ccm,ccd,error
  
  ! Convert to primitive variables
     
  ! Volume fraction and fluid density
  do imat = 1,nmat
     do k = 1,ncell
        fg(k,imat) = ug(k,imat+npri)
        fm(k,imat) = um(k,imat+npri)
        fd(k,imat) = ud(k,imat+npri)
        gg(k,imat) = ug(k,imat+npri+nmat)
        gm(k,imat) = um(k,imat+npri+nmat)
        gd(k,imat) = ud(k,imat+npri+nmat)
     end do
  end do
     
  ! Detect embedded body
  if(static)then
     do k=1,ncell
        bg(k)=fg(k,1)>0.01
        bm(k)=fm(k,1)>0.01
        bd(k)=fd(k,1)>0.01
     end do
     do k=1,ncell
        if(bm(k))then
           fg(k,1:nmat)=fm(k,1:nmat)
           gg(k,1:nmat)=gm(k,1:nmat)
           ug(k,1:nvar)=um(k,1:nvar)
           fd(k,1:nmat)=fm(k,1:nmat)
           gd(k,1:nmat)=gm(k,1:nmat)
           ud(k,1:nvar)=um(k,1:nvar)
        else
           if(bg(k))then
              fg(k,1:nmat)=fm(k,1:nmat)
              gg(k,1:nmat)=gm(k,1:nmat)
              ug(k,1:nvar)=um(k,1:nvar)
              ug(k,current_dim+1)=-um(k,current_dim+1)
           endif
           if(bd(k))then
              fd(k,1:nmat)=fm(k,1:nmat)
              gd(k,1:nmat)=gm(k,1:nmat)
              ud(k,1:nvar)=um(k,1:nvar)
              ud(k,current_dim+1)=-um(k,current_dim+1)
           endif
        endif
     enddo
  endif

  ! Compute total density
  do k = 1,ncell
     qg(k,1) = ug(k,1)
     qm(k,1) = um(k,1)
     qd(k,1) = ud(k,1)
  end do
  
  ! Compute velocity and specific kinetic energy
  eking(1:ncell)=0.0
  ekinm(1:ncell)=0.0
  ekind(1:ncell)=0.0
  do idim = 1,ndim
     do k = 1,ncell
        qg(k,idim+1) = ug(k,idim+1)/ug(k,1)
        qm(k,idim+1) = um(k,idim+1)/um(k,1)
        qd(k,idim+1) = ud(k,idim+1)/ud(k,1)
        eking(k) = eking(k) + half*qg(k,idim+1)**2
        ekinm(k) = ekinm(k) + half*qm(k,idim+1)**2
        ekind(k) = ekind(k) + half*qd(k,idim+1)**2
     end do
  end do
  
  ! Compute total internal energy
  do k = 1,ncell
     qg(k,npri) = ug(k,npri) - qg(k,1)*eking(k)
     qm(k,npri) = um(k,npri) - qm(k,1)*ekinm(k)
     qd(k,npri) = ud(k,npri) - qd(k,1)*ekind(k)
  end do
  
  ! Call eos routine
  call eos(fg,gg,qg,pg,cg,kappa_matg,kappa_hatg,ncell)
  call eos(fm,gm,qm,pm,cm,kappa_matm,kappa_hatm,ncell)
  call eos(fd,gd,qd,pd,cd,kappa_matd,kappa_hatd,ncell)
  
  ! Compute errors
  if(err_grad_d >= 0.)then
     do k=1,ncell
        ddg=abs(qg(k,1)); ddm=abs(qm(k,1)); ddd=abs(qd(k,1))
        error=2.0d0*MAX( &
             & ABS((ddd-ddm)/(ddd+ddm+floor_d)) , &
             & ABS((ddm-ddg)/(ddm+ddg+floor_d)) )
        ok(k) = ok(k) .or. error > err_grad_d
     end do
  end if

  if(err_grad_f >= 0.)then
     do imat=1,nmat
        do k=1,ncell
           ffg=fg(k,imat); ffm=fm(k,imat); ffd=fd(k,imat)
           error=2.0d0*MAX( &
                & ABS((ffd-ffm)/(ffd+ffm+floor_f)) , &
                & ABS((ffm-ffg)/(ffm+ffg+floor_f)) )
           ok(k) = ok(k) .or. error > err_grad_f
        end do
     end do
  end if

  if(err_grad_p > -1.0)then
     do k=1,ncell
        ppg=pg(k); ppm=pm(k); ppd=pd(k)
        error=2.0d0*MAX( &
             & ABS((ppd-ppm)/(ppd+ppm+floor_p)), &
             & ABS((ppm-ppg)/(ppm+ppg+floor_p)) )
        ok(k) = ok(k) .or. error > err_grad_p
     end do
  end if

  if(err_grad_u >= 0.)then
     do idim = 1,ndim
        do k=1,ncell
           vvg=qg(k,idim+1); vvm=qm(k,idim+1); vvd=qd(k,idim+1)
           ccg=cg(k)       ; ccm=cm(k)       ; ccd=cd(k)
           error=2.0d0*MAX( &
                & ABS((vvd-vvm)/(ccd+ccm+ABS(vvd)+ABS(vvm)+floor_u)) , &
                & ABS((vvm-vvg)/(ccm+ccg+ABS(vvm)+ABS(vvg)+floor_u)) )
           ok(k) = ok(k) .or. error > err_grad_u
        end do
     end do
  end if

!!   if(static)then
!!      do k=1,ncell
!!         if(wg(k).or.wd(k))then
!!            ddg=abs(qg(k,1)); ddm=abs(qm(k,1)); ddd=abs(qd(k,1))
!!            error=2.0d0*MAX( &
!!                 & ABS((ddd-ddm)/(ddd+ddm+floor_d)) , &
!!                 & ABS((ddm-ddg)/(ddm+ddg+floor_d)) )
!!            write(*,*)wg(k),wd(k)
!!            write(*,*)bg(k),bd(k)           
!!            write(*,*)ddg,ddm,ddd
!!            write(*,*)error,ok(k)
!!         endif
!!      end do
!!   endif

end subroutine hydro_refine
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine riemann_acoustic(fl,fr,gl,gr,ql,qr,cl,cr,fgdnv,ggdnv,qgdnv,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  ! dummy arguments
  integer::ngrid
  real(dp),dimension(1:nvector,1:npri)::ql,qr,qgdnv
  real(dp),dimension(1:nvector,1:nmat)::fl,fr,fgdnv
  real(dp),dimension(1:nvector,1:nmat)::gl,gr,ggdnv
  real(dp),dimension(1:nvector,1:nmat)::kappa_matl,kappa_matr
  real(dp),dimension(1:nvector)::cl,cr
  real(dp),dimension(1:nvector)::kappa_hatl,kappa_hatr

  ! local variables
  integer::i,n,ir,ie,imat
  real(dp)::smallp,delp_p

  ! local arrays
  real(dp),dimension(1:nvector,1:npri),save::qo,qstar
  real(dp),dimension(1:nvector,1:nmat),save::fo,fstar
  real(dp),dimension(1:nvector,1:nmat),save::go,gstar
  real(dp),dimension(1:nvector,1:nmat),save::kappa_matstar
  real(dp),dimension(1:nvector),save::cstar,estar,pstar,ustar
  real(dp),dimension(1:nvector),save::kappa_hatstar
  real(dp),dimension(1:nvector),save::sgnm ,spin ,spout,ushock
  real(dp),dimension(1:nvector),save::frac,co,el,er
  logical ,dimension(1:nvector),save::wall
  real(dp)::wl,wr,ul,ur,pl,pr,dl,dr,dstar

  ! Sound speed
  call eosinv(fl,gl,ql,el,cl,kappa_matl,kappa_hatl,ngrid)
  call eosinv(fr,gr,qr,er,cr,kappa_matr,kappa_hatr,ngrid)

  ! Acoustic star state
  do i=1,ngrid
     dl = ql(i,1); dr = qr(i,1)
     ul = ql(i,2); ur = qr(i,2)
     pl = ql(i,npri); pr = qr(i,npri)
     wl = cl(i)*dl
     wr = cr(i)*dr
     pstar(i) = ( (wr*pl+wl*pr)+wl*wr*(ul-ur) ) / (wl+wr)
     ustar(i) = ( (wr*ur+wl*ul)+      (pl-pr) ) / (wl+wr)
  end do

  ! Left going or right going contact wave
  do i=1,ngrid   
     sgnm(i) = sign(one,ustar(i))
  end do

  ! Left or right unperturbed state
  do i = 1,ngrid
     if(sgnm(i)==one)then
        fo(i,1:nmat) = fl(i,1:nmat)
        go(i,1:nmat) = gl(i,1:nmat)
        qo(i,1:npri) = ql(i,1:npri)
        co(i) = cl(i)
     else
        fo(i,1:nmat) = fr(i,1:nmat)
        go(i,1:nmat) = gr(i,1:nmat)
        qo(i,1:npri) = qr(i,1:npri)
        co(i) = cr(i)
     end if
  end do

  ! Star region density, internal energy and sound speed
  do i = 1,ngrid
     dstar = qo(i,1) + (pstar(i)-qo(i,npri))/co(i)**2
     dstar = max(dstar,smallr)
     fstar(i,1:nmat) = fo(i,1:nmat)
     gstar(i,1:nmat) = go(i,1:nmat)
     qstar(i,1) = dstar
     qstar(i,2) = ustar(i)
     qstar(i,npri) = pstar(i)
#if NDIM>1
     qstar(i,3) = qo(i,3)
#endif
#if NDIM>2
     qstar(i,4) = qo(i,4)
#endif
  end do
  call eosinv(fstar,gstar,qstar,estar,cstar,kappa_matstar,kappa_hatstar,ngrid)

  ! Head and tail speed of rarefaction
  do i=1,ngrid
     spout(i) = co   (i)-sgnm(i)*qo   (i,2)
     spin (i) = cstar(i)-sgnm(i)*qstar(i,2)
  end do

  ! Shock speed
  do i=1,ngrid
     ushock(i) = half*(spin(i)+spout(i))
     ushock(i) = max(ushock(i),-sgnm(i)*qstar(i,2))
  end do
  do i=1,ngrid
     if(pstar(i)>=qo(i,npri))then
        spout(i)=ushock(i)
        spin (i)=spout (i)
     end if
  end do

  ! Sample the solution at x/t=0
  do i=1,ngrid
     if(spout(i)<zero)then      ! Initial state
        qgdnv(i,1:npri) = qo(i,1:npri)
        fgdnv(i,1:nmat) = fo(i,1:nmat)
        ggdnv(i,1:nmat) = go(i,1:nmat)
     else if(spin(i)>=zero)then  ! Star region
        qgdnv(i,1:npri) = qstar(i,1:npri)
        fgdnv(i,1:nmat) = fstar(i,1:nmat)
        ggdnv(i,1:nmat) = gstar(i,1:nmat)
     else                        ! Rarefaction
        frac(i) = spout(i)/(spout(i)-spin(i))
        qgdnv(i,1:npri) = frac(i)*qstar(i,1:npri) + (one - frac(i))*qo(i,1:npri)
        fgdnv(i,1:nmat) = frac(i)*fstar(i,1:nmat) + (one - frac(i))*fo(i,1:nmat)
        ggdnv(i,1:nmat) = frac(i)*gstar(i,1:nmat) + (one - frac(i))*go(i,1:nmat)
     end if
  end do

end subroutine riemann_acoustic
!###########################################################
!###########################################################
!###########################################################
!###########################################################

../patch/multimat/godunov_utils_compdir.f90
#if (EOS == 0)
  include 'eos_sf.f90'
#elif (EOS == 1)
  include 'eos_mg.f90'
#elif (EOS == 2)
  include 'eos_cc.f90'
#endif 

!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine cmpdt(uu,grav,rr,dx,dt,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  integer::ncell
  real(dp)::dx,dt
  real(dp),dimension(1:nvector,1:nvar)::uu
  real(dp),dimension(1:nvector,1:ndim)::grav
  real(dp),dimension(1:nvector)::rr
  
  real(dp),dimension(1:nvector,1:npri),save::qq
  real(dp),dimension(1:nvector,1:nmat),save::ff,gg,kappa_matt
  real(dp),dimension(1:nvector),save::ekin,dtot,cc,st,pp,kappa_hatt
  real(dp)::dtcell,eps
  integer::k,idim,imat

  ! Convert to primitive variable
     
  ! Volume fraction and fluid density
  do imat = 1,nmat
     do k = 1,ncell
        ff(k,imat) = uu(k,imat+npri)
        gg(k,imat) = uu(k,imat+npri+nmat)
     end do
  end do
     
  ! Compute density
  do k = 1,ncell
     qq(k,1) = uu(k,1)
  end do
  
  ! Compute velocity and specific kinetic energy
  ekin(1:ncell)=0.0
  do idim = 1,ndim
     do k = 1,ncell
        qq(k,idim+1) = uu(k,idim+1)/uu(k,1)
        ekin(k) = ekin(k) + half*qq(k,idim+1)**2
     end do
  end do
  
  ! Compute total internal energy
  do k = 1,ncell
     qq(k,npri) = uu(k,npri) - uu(k,1)*ekin(k)
  end do
  
  ! Call eos routine
  call eos(ff,gg,qq,pp,cc,kappa_matt,kappa_hatt,ncell)
  
  ! Compute wave speed
  if(geom==3)then
     do k = 1,ncell
        eps = dx/two/rr(k)
        cc(k) = (abs(qq(k,2))+cc(k))*(one+eps)**2/(one+third*eps**2)
     end do
  else if(geom==2)then
     do k = 1,ncell
        eps = dx/two/rr(k)
        cc(k) = (abs(qq(k,2))+cc(k))*(one+eps)
     end do
  else
     do k = 1,ncell
        cc(k) = abs(qq(k,2))+cc(k)
     end do
  endif
  do idim = 2,ndim
     do k = 1,ncell 
        cc(k) = cc(k) + abs(qq(k,idim+1))+cc(k)
     end do
  end do

  ! Compute gravity strength ratio
  do k = 1,ncell
     st(k) = zero
  end do
  do idim = 1,ndim
     do k = 1,ncell 
        st(k) = st(k) + abs(grav(k,idim))
     end do
  end do
  do k = 1,ncell
     st(k) = st(k)*dx/cc(k)**2
     st(k) = MAX(st(k),0.0001_dp)
  end do

  ! Compute maximum time step for each authorized cell
  dt = courant_factor*dx/smallc
  do k = 1,ncell
     dtcell = dx/cc(k)*(sqrt(one+two*courant_factor*st(k))-one)/st(k)
     dt = min(dt,dtcell)
  end do

end subroutine cmpdt
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine hydro_refine(ug,um,ud,ok,current_dim,ncell)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  ! dummy arguments
  integer::ncell,current_dim
  real(dp),dimension(1:nvector,1:nvar)::ug,um,ud
  logical ,dimension(1:nvector)       ::ok
  
  integer::k,idim,imat
  real(dp),dimension(1:nvector,1:npri),save::qg,qm,qd
  real(dp),dimension(1:nvector,1:nmat),save::fg,fm,fd
  real(dp),dimension(1:nvector,1:nmat),save::gg,gm,gd
  real(dp),dimension(1:nvector,1:nmat),save::kappa_matg,kappa_matm,kappa_matd
  real(dp),dimension(1:nvector),save::eking,ekinm,ekind
  real(dp),dimension(1:nvector),save::pg,pm,pd
  real(dp),dimension(1:nvector),save::cg,cm,cd
  real(dp),dimension(1:nvector),save::kappa_hatg,kappa_hatm,kappa_hatd
  logical ,dimension(1:nvector),save::wg,wd,bg,bm,bd
  real(dp)::ffg,ffm,ffd,ddg,ddm,ddd
  real(dp)::ppg,ppm,ppd,vvg,vvm,vvd
  real(dp)::ccg,ccm,ccd,error
  
  ! Convert to primitive variables
     
  ! Volume fraction and fluid density
  do imat = 1,nmat
     do k = 1,ncell
        fg(k,imat) = ug(k,imat+npri)
        fm(k,imat) = um(k,imat+npri)
        fd(k,imat) = ud(k,imat+npri)
        gg(k,imat) = ug(k,imat+npri+nmat)
        gm(k,imat) = um(k,imat+npri+nmat)
        gd(k,imat) = ud(k,imat+npri+nmat)
     end do
  end do
     
  ! Detect embedded body
  if(static)then
     do k=1,ncell
        bg(k)=fg(k,1)>0.01
        bm(k)=fm(k,1)>0.01
        bd(k)=fd(k,1)>0.01
     end do
     do k=1,ncell
        if(bm(k))then
           fg(k,1:nmat)=fm(k,1:nmat)
           gg(k,1:nmat)=gm(k,1:nmat)
           ug(k,1:nvar)=um(k,1:nvar)
           fd(k,1:nmat)=fm(k,1:nmat)
           gd(k,1:nmat)=gm(k,1:nmat)
           ud(k,1:nvar)=um(k,1:nvar)
        else
           if(bg(k))then
              fg(k,1:nmat)=fm(k,1:nmat)
              gg(k,1:nmat)=gm(k,1:nmat)
              ug(k,1:nvar)=um(k,1:nvar)
              ug(k,current_dim+1)=-um(k,current_dim+1)
           endif
           if(bd(k))then
              fd(k,1:nmat)=fm(k,1:nmat)
              gd(k,1:nmat)=gm(k,1:nmat)
              ud(k,1:nvar)=um(k,1:nvar)
              ud(k,current_dim+1)=-um(k,current_dim+1)
           endif
        endif
     enddo
  endif

  ! Compute total density
  do k = 1,ncell
     qg(k,1) = ug(k,1)
     qm(k,1) = um(k,1)
     qd(k,1) = ud(k,1)
  end do
  
  ! Compute velocity and specific kinetic energy
  eking(1:ncell)=0.0
  ekinm(1:ncell)=0.0
  ekind(1:ncell)=0.0
  do idim = 1,ndim
     do k = 1,ncell
        qg(k,idim+1) = ug(k,idim+1)/ug(k,1)
        qm(k,idim+1) = um(k,idim+1)/um(k,1)
        qd(k,idim+1) = ud(k,idim+1)/ud(k,1)
        eking(k) = eking(k) + half*qg(k,idim+1)**2
        ekinm(k) = ekinm(k) + half*qm(k,idim+1)**2
        ekind(k) = ekind(k) + half*qd(k,idim+1)**2
     end do
  end do
  
  ! Compute total internal energy
  do k = 1,ncell
     qg(k,npri) = ug(k,npri) - qg(k,1)*eking(k)
     qm(k,npri) = um(k,npri) - qm(k,1)*ekinm(k)
     qd(k,npri) = ud(k,npri) - qd(k,1)*ekind(k)
  end do
  
  ! Call eos routine
  call eos(fg,gg,qg,pg,cg,kappa_matg,kappa_hatg,ncell)
  call eos(fm,gm,qm,pm,cm,kappa_matm,kappa_hatm,ncell)
  call eos(fd,gd,qd,pd,cd,kappa_matd,kappa_hatd,ncell)
  
  ! Compute errors
  if(err_grad_d >= 0.)then
     do k=1,ncell
        ddg=abs(qg(k,1)); ddm=abs(qm(k,1)); ddd=abs(qd(k,1))
        error=2.0d0*MAX( &
             & ABS((ddd-ddm)/(ddd+ddm+floor_d)) , &
             & ABS((ddm-ddg)/(ddm+ddg+floor_d)) )
        ok(k) = ok(k) .or. error > err_grad_d
     end do
  end if

  if(err_grad_f >= 0.)then
     do imat=1,nmat
        do k=1,ncell
           ffg=fg(k,imat); ffm=fm(k,imat); ffd=fd(k,imat)
           error=2.0d0*MAX( &
                & ABS((ffd-ffm)/(ffd+ffm+floor_f)) , &
                & ABS((ffm-ffg)/(ffm+ffg+floor_f)) )
           ok(k) = ok(k) .or. error > err_grad_f
        end do
     end do
  end if

  if(err_grad_p > -1.0)then
     do k=1,ncell
        ppg=pg(k); ppm=pm(k); ppd=pd(k)
        error=2.0d0*MAX( &
             & ABS((ppd-ppm)/(ppd+ppm+floor_p)), &
             & ABS((ppm-ppg)/(ppm+ppg+floor_p)) )
        ok(k) = ok(k) .or. error > err_grad_p
     end do
  end if

  if(err_grad_u >= 0.)then
     do idim = 1,ndim
        do k=1,ncell
           vvg=qg(k,idim+1); vvm=qm(k,idim+1); vvd=qd(k,idim+1)
           ccg=cg(k)       ; ccm=cm(k)       ; ccd=cd(k)
           error=2.0d0*MAX( &
                & ABS((vvd-vvm)/(ccd+ccm+ABS(vvd)+ABS(vvm)+floor_u)) , &
                & ABS((vvm-vvg)/(ccm+ccg+ABS(vvm)+ABS(vvg)+floor_u)) )
           ok(k) = ok(k) .or. error > err_grad_u
        end do
     end do
  end if

!!   if(static)then
!!      do k=1,ncell
!!         if(wg(k).or.wd(k))then
!!            ddg=abs(qg(k,1)); ddm=abs(qm(k,1)); ddd=abs(qd(k,1))
!!            error=2.0d0*MAX( &
!!                 & ABS((ddd-ddm)/(ddd+ddm+floor_d)) , &
!!                 & ABS((ddm-ddg)/(ddm+ddg+floor_d)) )
!!            write(*,*)wg(k),wd(k)
!!            write(*,*)bg(k),bd(k)           
!!            write(*,*)ddg,ddm,ddd
!!            write(*,*)error,ok(k)
!!         endif
!!      end do
!!   endif

end subroutine hydro_refine
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine riemann_acoustic(fl,fr,gl,gr,ql,qr,cl,cr,fgdnv,ggdnv,qgdnv,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  ! dummy arguments
  integer::ngrid
  real(dp),dimension(1:nvector,1:npri)::ql,qr,qgdnv
  real(dp),dimension(1:nvector,1:nmat)::fl,fr,fgdnv
  real(dp),dimension(1:nvector,1:nmat)::gl,gr,ggdnv
  real(dp),dimension(1:nvector,1:nmat)::kappa_matl,kappa_matr
  real(dp),dimension(1:nvector)::cl,cr
  real(dp),dimension(1:nvector)::kappa_hatl,kappa_hatr

  ! local variables
  integer::i,n,ir,ie,imat
  real(dp)::smallp,delp_p

  ! local arrays
  real(dp),dimension(1:nvector,1:npri),save::qo,qstar
  real(dp),dimension(1:nvector,1:nmat),save::fo,fstar
  real(dp),dimension(1:nvector,1:nmat),save::go,gstar
  real(dp),dimension(1:nvector,1:nmat),save::kappa_matstar
  real(dp),dimension(1:nvector),save::cstar,estar,pstar,ustar
  real(dp),dimension(1:nvector),save::kappa_hatstar
  real(dp),dimension(1:nvector),save::sgnm ,spin ,spout,ushock
  real(dp),dimension(1:nvector),save::frac,co,el,er
  logical ,dimension(1:nvector),save::wall
  real(dp)::wl,wr,ul,ur,pl,pr,dl,dr,dstar

  ! Sound speed
  call eosinv(fl,gl,ql,el,cl,kappa_matl,kappa_hatl,ngrid)
  call eosinv(fr,gr,qr,er,cr,kappa_matr,kappa_hatr,ngrid)

  ! Acoustic star state
  do i=1,ngrid
     dl = ql(i,1); dr = qr(i,1)
     ul = ql(i,2); ur = qr(i,2)
     pl = ql(i,npri); pr = qr(i,npri)
     wl = cl(i)*dl
     wr = cr(i)*dr
     pstar(i) = ( (wr*pl+wl*pr)+wl*wr*(ul-ur) ) / (wl+wr)
     ustar(i) = ( (wr*ur+wl*ul)+      (pl-pr) ) / (wl+wr)
  end do

  ! Left going or right going contact wave
  do i=1,ngrid   
     sgnm(i) = sign(one,ustar(i))
  end do

  ! Left or right unperturbed state
  do i = 1,ngrid
     if(sgnm(i)==one)then
        fo(i,1:nmat) = fl(i,1:nmat)
        go(i,1:nmat) = gl(i,1:nmat)
        qo(i,1:npri) = ql(i,1:npri)
        co(i) = cl(i)
     else
        fo(i,1:nmat) = fr(i,1:nmat)
        go(i,1:nmat) = gr(i,1:nmat)
        qo(i,1:npri) = qr(i,1:npri)
        co(i) = cr(i)
     end if
  end do

  ! Star region density, internal energy and sound speed
  do i = 1,ngrid
     dstar = qo(i,1) + (pstar(i)-qo(i,npri))/co(i)**2
     dstar = max(dstar,smallr)
     fstar(i,1:nmat) = fo(i,1:nmat)
     gstar(i,1:nmat) = go(i,1:nmat)
     qstar(i,1) = dstar
     qstar(i,2) = ustar(i)
     qstar(i,npri) = pstar(i)
#if NDIM>1
     qstar(i,3) = qo(i,3)
#endif
#if NDIM>2
     qstar(i,4) = qo(i,4)
#endif
  end do
  call eosinv(fstar,gstar,qstar,estar,cstar,kappa_matstar,kappa_hatstar,ngrid)

  ! Head and tail speed of rarefaction
  do i=1,ngrid
     spout(i) = co   (i)-sgnm(i)*qo   (i,2)
     spin (i) = cstar(i)-sgnm(i)*qstar(i,2)
  end do

  ! Shock speed
  do i=1,ngrid
     ushock(i) = half*(spin(i)+spout(i))
     ushock(i) = max(ushock(i),-sgnm(i)*qstar(i,2))
  end do
  do i=1,ngrid
     if(pstar(i)>=qo(i,npri))then
        spout(i)=ushock(i)
        spin (i)=spout (i)
     end if
  end do

  ! Sample the solution at x/t=0
  do i=1,ngrid
     if(spout(i)<zero)then      ! Initial state
        qgdnv(i,1:npri) = qo(i,1:npri)
        fgdnv(i,1:nmat) = fo(i,1:nmat)
        ggdnv(i,1:nmat) = go(i,1:nmat)
     else if(spin(i)>=zero)then  ! Star region
        qgdnv(i,1:npri) = qstar(i,1:npri)
        fgdnv(i,1:nmat) = fstar(i,1:nmat)
        ggdnv(i,1:nmat) = gstar(i,1:nmat)
     else                        ! Rarefaction
        frac(i) = spout(i)/(spout(i)-spin(i))
        qgdnv(i,1:npri) = frac(i)*qstar(i,1:npri) + (one - frac(i))*qo(i,1:npri)
        fgdnv(i,1:nmat) = frac(i)*fstar(i,1:nmat) + (one - frac(i))*fo(i,1:nmat)
        ggdnv(i,1:nmat) = frac(i)*gstar(i,1:nmat) + (one - frac(i))*go(i,1:nmat)
     end if
  end do

end subroutine riemann_acoustic
!###########################################################
!###########################################################
!###########################################################
!###########################################################

../patch/multimat/hydro_flag.f90
subroutine hydro_flag(ilevel)
  use amr_commons
  use hydro_commons
  implicit none
  integer::ilevel
  ! -------------------------------------------------------------------
  ! This routine flag for refinement cells that satisfies
  ! some user-defined physical criteria at the level ilevel. 
  ! -------------------------------------------------------------------
  integer::i,j,ncache,nok,ix,iy,iz,iskip
  integer::igrid,ind,idim,ngrid,ivar
  integer::nx_loc
  integer,dimension(1:nvector),save::ind_grid,ind_cell
  integer,dimension(1:nvector,0:twondim),save::igridn
  integer,dimension(1:nvector,1:twondim),save::indn

  logical,dimension(1:nvector),save::ok

  real(dp)::dx,dx_loc,scale,scale_var
  real(dp),dimension(1:3)::skip_loc
  real(dp),dimension(1:twotondim,1:3)::xc
  real(dp),dimension(1:nvector,1:ndim),save::xx
  real(dp),dimension(1:nvector,1:nvar),save::uug,uum,uud
  real(dp),dimension(1:nvector,1:nmat),save::gampg,gampm,gampd
  real(dp),dimension(1:nvector,1:nmat),save::gamcg,gamcm,gamcd

  if(ilevel==nlevelmax)return
  if(numbtot(1,ilevel)==0)return

  ! Rescaling factors
  dx=0.5d0**ilevel
  nx_loc=(icoarse_max-icoarse_min+1)
  skip_loc=(/0.0d0,0.0d0,0.0d0/)
  if(ndim>0)skip_loc(1)=dble(icoarse_min)
  if(ndim>1)skip_loc(2)=dble(jcoarse_min)
  if(ndim>2)skip_loc(3)=dble(kcoarse_min)
  scale=boxlen/dble(nx_loc)
  dx_loc=dx*scale

  ! Set position of cell centers relative to grid center
  do ind=1,twotondim
     iz=(ind-1)/4
     iy=(ind-1-4*iz)/2
     ix=(ind-1-2*iy-4*iz)
     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx
     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx
     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx
  end do

  if(    err_grad_d==-1.0.and.&
       & err_grad_p==-1.0.and.&
       & err_grad_u==-1.0.and.&
       & err_grad_f==-1.0 )return

  ! Loop over active grids
  ncache=active(ilevel)%ngrid
  do igrid=1,ncache,nvector

     ! Gather nvector grids
     ngrid=MIN(nvector,ncache-igrid+1)
     do i=1,ngrid
        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)
     end do

     ! Gather neighboring offsets
     call getnborgrids(ind_grid,igridn,ngrid)

     ! Loop over cells
     do ind=1,twotondim

        iskip=ncoarse+(ind-1)*ngridmax
        do i=1,ngrid
           ind_cell(i)=iskip+ind_grid(i)
        end do

        ! Initialize refinement to false
        do i=1,ngrid
           ok(i)=.false.
        end do

        ! Gather neighboring cells
        call getnborcells(igridn,ind,indn,ngrid)

        ! If a neighbor cell does not exist,
        ! replace it by its father cell
        do j=1,twondim
           do i=1,ngrid
              if(indn(i,j)==0)then
                 indn(i,j)=nbor(ind_grid(i),j)
              end if
           end do
        end do

        ! Loop over dimensions
        do idim=1,ndim

           ! Gather hydro variables
           do ivar=1,nvar
              do i=1,ngrid
                 uug(i,ivar)=uold(indn(i,2*idim-1),ivar)
                 uum(i,ivar)=uold(ind_cell(i     ),ivar)
                 uud(i,ivar)=uold(indn(i,2*idim  ),ivar)
              end do
           end do
           call hydro_refine(uug,uum,uud,ok,idim,ngrid)

        end do
     
        ! Apply geometry-based refinement criteria
        if(r_refine(ilevel)>-1.0)then
           ! Compute cell center in code units
           do idim=1,ndim
              do i=1,ngrid
                 xx(i,idim)=xg(ind_grid(i),idim)+xc(ind,idim)
              end do
           end do
           ! Rescale position from code units to user units
           do idim=1,ndim
              do i=1,ngrid
                 xx(i,idim)=(xx(i,idim)-skip_loc(idim))*scale
              end do
           end do
           call geometry_refine(xx,ok,ngrid,ilevel)
        end if

        ! Count newly flagged cells
        nok=0
        do i=1,ngrid
           if(flag1(ind_cell(i))==0.and.ok(i))then
              nok=nok+1
           end if
        end do
     
        do i=1,ngrid
           if(ok(i))flag1(ind_cell(i))=1
        end do
        
        nflag=nflag+nok
     end do
     ! End loop over cells
     
  end do
  ! End loop over grids

end subroutine hydro_flag




../patch/multimat/hydro_parameters.f90
module hydro_parameters

#ifdef grackle
  use grackle_parameters
#endif
  use amr_parameters

  ! Number of independant variables
#ifndef NMAT
  integer,parameter::nmat=2
#else
  integer,parameter::nmat=NMAT
#endif
#ifndef NENER
  integer,parameter::nener=0
#else
  integer,parameter::nener=NENER
#endif
#ifndef NVAR
  integer,parameter::nvar=ndim+2+2*nmat+nener
#else
  integer,parameter::nvar=NVAR
#endif
  integer,parameter::npri=ndim+2

  ! Size of hydro kernel
  integer,parameter::iu1=-1
  integer,parameter::iu2=+4
  integer,parameter::ju1=(1-ndim/2)-1*(ndim/2)
  integer,parameter::ju2=(1-ndim/2)+4*(ndim/2)
  integer,parameter::ku1=(1-ndim/3)-1*(ndim/3)
  integer,parameter::ku2=(1-ndim/3)+4*(ndim/3)
  integer,parameter::if1=1
  integer,parameter::if2=3
  integer,parameter::jf1=1
  integer,parameter::jf2=(1-ndim/2)+3*(ndim/2)
  integer,parameter::kf1=1
  integer,parameter::kf2=(1-ndim/3)+3*(ndim/3)

  ! Imposed boundary condition variables
  real(dp),dimension(1:MAXBOUND,1:nvar)::boundary_var
  real(dp),dimension(1:MAXBOUND)::d1_bound=0,d2_bound=0,d3_bound=0,d4_bound=0
  real(dp),dimension(1:MAXBOUND)::f1_bound=0,f2_bound=0,f3_bound=0,f4_bound=0
  real(dp),dimension(1:MAXBOUND)::u_bound=0,v_bound=0,w_bound=0,p_bound=0

  ! Refinement parameters for hydro
  real(dp)::err_grad_f=-1.0d0    ! Volume fraction 
  real(dp)::err_grad_d=-1.0d0    ! Density gradient
  real(dp)::err_grad_u=-1.0d0    ! Velocity gradient
  real(dp)::err_grad_p=-1.0d0    ! Pressure gradient
  real(dp)::floor_f=1d-10     ! Fraction floor
  real(dp)::floor_d=1d-10     ! Density floor
  real(dp)::floor_u=1d-10     ! Velocity floor
  real(dp)::floor_p=1d-10     ! Pressure floor
  real(dp)::mass_sph=0.0d0     ! mass_sph

  ! Initial conditions hydro variables
  real(dp),dimension(1:MAXREGION)::d1_region=0,d2_region=0,d3_region=0,d4_region=0
  real(dp),dimension(1:MAXREGION)::f1_region=0,f2_region=0,f3_region=0,f4_region=0
  real(dp),dimension(1:MAXREGION)::u_region=0.,v_region=0.,w_region=0.
  real(dp),dimension(1:MAXREGION)::p_region=0.

  ! Multi-material properties
  integer ,dimension(1:100)::eos_type=0 ! Perfect gas
  real(dp),dimension(1:100,1:10)::eos_params=1.4
  character(LEN=128),dimension(1:100)::eos_file=' '

  ! Hydro solver parameters
  integer ::geom=1
  integer ::slope_type=1
  real(dp)::gamma=-999d0
  real(dp)::courant_factor=0.5d0
  real(dp)::difmag=0
  real(dp)::smallc=1.0d-10
  real(dp)::smallr=1.0d-10
  real(dp)::smallf=1.0d-10
  character(LEN=10)::scheme='muscl'
  character(LEN=20)::eos_name='mie-grueneisen'

  ! Interpolation parameters
  integer ::interpol_var=0
  integer ::interpol_type=1

  ! Passive variables index
  integer::imetal=6
  integer::idelay=6
  integer::ixion=6
  integer::ichem=6
  integer::ivirial1=6
  integer::ivirial2=6
  integer::inener=6

end module hydro_parameters
../patch/multimat/init_flow_fine.f90
!################################################################
!################################################################
!################################################################
!################################################################
subroutine init_flow
  use amr_commons
  use hydro_commons, ONLY: nvar, uold
  implicit none

  integer::ilevel,ivar
  
  if(verbose)write(*,*)'Entering init_flow'
  do ilevel=nlevelmax,1,-1
     if(ilevel>=levelmin)call init_flow_fine(ilevel)
     call upload_fine(ilevel)
     do ivar=1,nvar
        call make_virtual_fine_dp(uold(1,ivar),ilevel)
     end do
     if(simple_boundary)call make_boundary_hydro(ilevel)
  end do
  if(verbose)write(*,*)'Complete init_flow'

end subroutine init_flow
!################################################################
!################################################################
!################################################################
!################################################################
subroutine init_flow_fine(ilevel)
  use amr_commons
  use hydro_commons
  use cooling_module
  implicit none
  integer::ilevel
  
  integer::i,icell,igrid,ncache,iskip,ngrid
  integer::ind,idim,ivar,imat,ix,iy,iz,nx_loc
  integer::i1,i2,i3,i1_min,i1_max,i2_min,i2_max,i3_min,i3_max
  integer ,dimension(1:nvector),save::ind_grid,ind_cell

  real(dp)::dx,rr,vx,vy,vz,ek,ei,scale_T2,xx1,xx2,xx3,dx_loc,scale
  real(dp),dimension(1:3)::skip_loc
  real(dp),dimension(1:twotondim,1:3)::xc
  real(dp),dimension(1:nvector)       ,save::vv
  real(dp),dimension(1:nvector,1:ndim),save::xx
  real(dp),dimension(1:nvector,1:nvar),save::uu

  real(dp),allocatable,dimension(:,:,:)::init_array
  real(sp),allocatable,dimension(:,:)  ::init_plane

  logical::error
  character(LEN=80)::filename

  ncache=active(ilevel)%ngrid
  if(ncache==0)return
  if(verbose)write(*,111)ilevel

  ! Mesh size at level ilevel in coarse cell units
  dx=0.5D0**ilevel
  
  ! Set position of cell centers relative to grid center
  do ind=1,twotondim
     iz=(ind-1)/4
     iy=(ind-1-4*iz)/2
     ix=(ind-1-2*iy-4*iz)
     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx
     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx
     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx
  end do
  
  !-------------------------------------------------------
  ! Compute initial conditions from subroutine condinit
  !-------------------------------------------------------
  ! Local constants
  nx_loc=(icoarse_max-icoarse_min+1)
  scale=boxlen/dble(nx_loc)
  skip_loc=(/0.0d0,0.0d0,0.0d0/)
  if(ndim>0)skip_loc(1)=dble(icoarse_min)
  if(ndim>1)skip_loc(2)=dble(jcoarse_min)
  if(ndim>2)skip_loc(3)=dble(kcoarse_min)
  dx_loc=dx*scale
  
  ! Loop over grids by vector sweeps
  do igrid=1,ncache,nvector
     ngrid=MIN(nvector,ncache-igrid+1)
     do i=1,ngrid
        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)
     end do
     ! Loop over cells
     do ind=1,twotondim
        ! Gather cell indices
        iskip=ncoarse+(ind-1)*ngridmax
        do i=1,ngrid
           ind_cell(i)=iskip+ind_grid(i)
        end do
        ! Gather cell centre positions
        do idim=1,ndim
           do i=1,ngrid
              xx(i,idim)=xg(ind_grid(i),idim)+xc(ind,idim)
           end do
        end do
        ! Rescale position from code units to user units
        do idim=1,ndim
           do i=1,ngrid
              xx(i,idim)=(xx(i,idim)-skip_loc(idim))*scale
           end do
        end do
        ! Call initial condition routine
        call condinit(xx,uu,dx_loc,ngrid)
        ! Scatter variables
        do ivar=1,nvar
           do i=1,ngrid
              uold(ind_cell(i),ivar)=uu(i,ivar)
           end do
        end do
     end do
     ! End loop over cells
  end do
  ! End loop over grids

111 format('   Entering init_flow_fine for level ',I2)

end subroutine init_flow_fine
!################################################################
!################################################################
!################################################################
!################################################################
subroutine region_condinit(x,q,f,g,dx,nn)
  use amr_parameters
  use hydro_parameters
  implicit none
  integer ::nn
  real(dp)::dx
  real(dp),dimension(1:nvector,1:npri)::q
  real(dp),dimension(1:nvector,1:nmat)::f,g
  real(dp),dimension(1:nvector,1:ndim)::x

  integer::i,ivar,imat,k
  real(dp)::vol,r,xn,yn,zn,en,ftot,radius,twopi,fourpi

  fourpi=4.0d0*ACOS(-1.0d0)
  twopi=2.0d0*ACOS(-1.0d0)

  ! Set some (tiny) default values in case n_region=0
  q(1:nn,1)=smallr
  q(1:nn,2)=0.0d0
#if NDIM>1
  q(1:nn,3)=0.0d0
#endif
#if NDIM>2
  q(1:nn,4)=0.0d0
#endif
  q(1:nn,npri)=smallr*smallc**2
  do imat=1,nmat
     f(1:nn,imat)=smallf
     g(1:nn,imat)=smallf
  end do

  ! Loop over initial conditions regions
  do k=1,nregion
     
     ! For 'square' regions only:
     if(region_type(k) .eq. 'square')then

        ! Exponent of choosen norm
        en=exp_region(k)

        do i=1,nn

           ! Compute position in normalized coordinates
           xn=0.0d0; yn=0.0d0; zn=0.0d0
           xn=2.0d0*abs(x(i,1)-x_center(k))/length_x(k)
#if NDIM>1
           yn=2.0d0*abs(x(i,2)-y_center(k))/length_y(k)
#endif
#if NDIM>2
           zn=2.0d0*abs(x(i,3)-z_center(k))/length_z(k)
#endif
           ! Compute cell 'radius' relative to region center
           if(exp_region(k)<10)then
              r=(xn**en+yn**en+zn**en)**(1.0/en)
           else
              r=max(xn,yn,zn)
           end if

           ! If cell lies within region,
           ! REPLACE primitive variables by region values
           if(r<1.0)then
              imat=1
              f(i,imat)=max(f1_region(k),smallf)
              g(i,imat)=max(d1_region(k),smallr)
              if(nmat>1)then
                 imat=imat+1
                 f(i,imat)=max(f2_region(k),smallf)
                 g(i,imat)=max(d2_region(k),smallr)
              end if
              if(nmat>2)then
                 imat=imat+1
                 f(i,imat)=max(f3_region(k),smallf)
                 g(i,imat)=max(d3_region(k),smallr)
              end if
              if(nmat>3)then
                 imat=imat+1
                 f(i,imat)=max(f4_region(k),smallf)
                 g(i,imat)=max(d4_region(k),smallr)
              end if
              ! Normalize volume fractions
              ftot=1d-15
              do imat=1,nmat
                 ftot=ftot+f(i,imat)
              end do
              do imat=1,nmat
                 f(i,imat)=f(i,imat)/ftot
              end do
              ! Compute total density
              q(i,1)=0.0
              do imat=1,nmat
                 q(i,1)=q(i,1)+f(i,imat)*g(i,imat)
              end do
              ! Compute velocities
              q(i,2)=u_region(k)
#if NDIM>1
              q(i,3)=v_region(k)
#endif
#if NDIM>2
              q(i,4)=w_region(k)
#endif
              ! Compute pressure
              q(i,npri)=max(p_region(k),smallr*smallc**2)
           end if

        end do
     end if

     ! For 'point' regions only:
     if(region_type(k) .eq. 'point')then
        radius=x_center(k)
        if(geom>1)then
           radius=max(radius,dx/2.0)
        endif
        ! Volume elements
        vol=dx**ndim
        ! Compute CIC weights relative to region center
        do i=1,nn
           xn=1.0; yn=1.0; zn=1.0
           xn=max(1.0-abs(x(i,1)-radius     )/dx,0.0_dp)
#if NDIM>1
           yn=max(1.0-abs(x(i,2)-y_center(k))/dx,0.0_dp)
#endif
#if NDIM>2
           zn=max(1.0-abs(x(i,3)-z_center(k))/dx,0.0_dp)
#endif
           r=xn*yn*zn
           if(geom==2)r=r/(twopi*x(i,1))
           if(geom==3)r=r/(fourpi*(x(i,1)**2+dx**2/12.0))

           ! If cell lies within CIC cloud, 
           ! ADD to primitive variables the region values
           q(i,1)=q(i,1)!+d_region(k)*r/vol
           q(i,2)=q(i,2)+u_region(k)*r
#if NDIM>1
           q(i,3)=q(i,3)+v_region(k)*r
#endif
#if NDIM>2
           q(i,4)=q(i,4)+w_region(k)*r
#endif
           q(i,ndim+2)=q(i,ndim+2)+p_region(k)*r/vol
        end do
     end if
 
  end do

  return
end subroutine region_condinit
../patch/multimat/init_hydro.f90
subroutine init_hydro
  use amr_commons
  use hydro_commons
  implicit none
  integer::ncell,ncache,iskip,igrid,i,ilevel,ind,ivar
  integer::nvar2,ilevel2,numbl2,ilun
  integer ,dimension(:),allocatable::ind_grid
  real(dp),dimension(:),allocatable::xx
  character(LEN=80)::fileloc
  character(LEN=5)::nchar

  if(verbose)write(*,*)'Entering init_hydro'

  ncell=ncoarse+twotondim*ngridmax
  
  ! Allocate conservative, cell-centered variables arrays
  allocate(uold(1:ncell,1:nvar))
  allocate(unew(1:ncell,1:nvar))
  uold=0.0d0; unew=0.0d0 
  allocate(divu(1:ncell))
  divu=0.0d0  

  if(nrestart>0)then

     ilun=ncpu+myid+10
     call title(nrestart,nchar)
     fileloc='backup_'//TRIM(nchar)//'/hydro_'//TRIM(nchar)//'.bak'
     call title(myid,nchar)
     fileloc=TRIM(fileloc)//TRIM(nchar)
     open(unit=ilun,file=fileloc,form='unformatted')
     read(ilun)nvar2
     if(nvar2.ne.nvar)then
        write(*,*)'File hydro.tmp is not compatible'
        write(*,*)'Found   =',nvar2
        write(*,*)'Expected=',nvar
        call clean_stop
     end if
     do ilevel=1,nlevelmax
        read(ilun)ilevel2
        read(ilun)numbl2
        if(numbl2.ne.numbl(myid,ilevel))then
           write(*,*)'File hydro.tmp is not compatible for level',ilevel
           write(*,*)'Found   =',numbl2,ilevel2
           write(*,*)'Expected=',numbl(myid,ilevel)
        end if
        if(numbl(myid,ilevel)>0)then
           ncache=numbl(myid,ilevel)
           allocate(ind_grid(1:ncache))
           allocate(xx(1:ncache))
           ! Loop over level grids
           igrid=headl(myid,ilevel)
           do i=1,ncache
              ind_grid(i)=igrid
              igrid=next(igrid)
           end do
           ! Loop over cells
           do ind=1,twotondim
              iskip=ncoarse+(ind-1)*ngridmax
              ! Loop over conservative variables
              do ivar=1,nvar
                 read(ilun)xx
                 do i=1,ncache
                    uold(ind_grid(i)+iskip,ivar)=xx(i)
                 end do
              end do
           end do
           deallocate(ind_grid,xx)
        end if
     end do
     close(ilun)

     ! Update boundaries
     do ilevel=1,nlevelmax
        do ivar=1,nvar
           call make_virtual_fine_dp(uold(1,ivar),ilevel)
        end do
        if(simple_boundary)call make_boundary_hydro(ilevel)
     end do

  end if

end subroutine init_hydro




../patch/multimat/interpol_hydro.f90
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine upload_fine(ilevel)
  use amr_commons
  use hydro_commons
  implicit none
  integer::ilevel
  !----------------------------------------------------------------------
  ! This routine performs a restriction operation (averaging down)
  ! for the hydro variables.
  !----------------------------------------------------------------------
  integer::i,ncache,igrid,ngrid,ind,iskip,nsplit,icell
  integer,dimension(1:nvector),save::ind_grid,ind_cell,ind_split
  logical,dimension(1:nvector),save::ok

  if(ilevel==nlevelmax)return
  if(numbl(myid,ilevel)==0)return
  if(verbose)write(*,111)ilevel

  ! Loop over active grids by vector sweeps
  ncache=active(ilevel)%ngrid
  do igrid=1,ncache,nvector
     ngrid=MIN(nvector,ncache-igrid+1)
     do i=1,ngrid
        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)
     end do
 
     ! Loop over cells
     do ind=1,twotondim
        iskip=ncoarse+(ind-1)*ngridmax
        do i=1,ngrid
           ind_cell(i)=iskip+ind_grid(i)
        end do
        
        ! Gather split cells
        do i=1,ngrid
           ok(i)=son(ind_cell(i))>0
        end do
        
        ! Count split cells
        nsplit=0
        do i=1,ngrid
           if(ok(i))nsplit=nsplit+1
        end do
        
        ! Upload for selected cells
        if(nsplit>0)then
           icell=0
           do i=1,ngrid
              if(ok(i))then
                 icell=icell+1
                 ind_split(icell)=ind_cell(i)
              end if
           end do
           call upl(ind_split,nsplit)
        end if
        
     end do
     ! End loop over cells

  end do
  ! End loop over grids

111 format('   Entering upload_fine for level',i2)

end subroutine upload_fine
!##########################################################################
!##########################################################################
!##########################################################################
!##########################################################################
subroutine upl(ind_cell,ncell)
  use amr_commons
  use hydro_commons
  implicit none
  integer::ncell
  integer,dimension(1:nvector)::ind_cell
  !---------------------------------------------------------------------
  ! This routine performs a restriction operation (averaging down)
  ! for the following variables:
  ! interpol_var=0: use rho, rho u and E
  ! interpol_tar=1: use rho, rho u and rho epsilon
  !---------------------------------------------------------------------
  integer ::ivar,i,idim,ind_son,iskip_son
  integer ,dimension(1:nvector),save::igrid_son,ind_cell_son
  real(dp),dimension(1:nvector),save::getx,ekin

  ! Get child oct index
  do i=1,ncell
     igrid_son(i)=son(ind_cell(i))
  end do

  ! Loop over variables
  do ivar=1,nvar     
     
     ! Average conservative variable
     getx(1:ncell)=0.0d0
     do ind_son=1,twotondim
        iskip_son=ncoarse+(ind_son-1)*ngridmax
        do i=1,ncell
           ind_cell_son(i)=iskip_son+igrid_son(i)
        end do
        do i=1,ncell
           getx(i)=getx(i)+uold(ind_cell_son(i),ivar)
        end do
     end do
     
     ! Scatter result to cells
     do i=1,ncell
        uold(ind_cell(i),ivar)=getx(i)/dble(twotondim)
     end do

  end do
  ! End loop over variables


end subroutine upl
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine interpol_hydro(u1,u2,nn)
  use amr_commons
  use hydro_commons
  use poisson_commons
  implicit none
  integer::nn
  real(dp),dimension(1:nvector,0:twondim  ,1:nvar)::u1
  real(dp),dimension(1:nvector,1:twotondim,1:nvar)::u2
  !----------------------------------------------------------
  ! This routine performs a prolongation (interpolation)
  ! operation for newly refined cells or buffer cells.
  ! The interpolated variables are:
  ! interpol_var=0: rho, rho u and E
  ! interpol_var=1: rho, rho u and rho epsilon
  ! The interpolation method is:
  ! interpol_type=0 straight injection
  ! interpol_type=1 linear interpolation with MinMod slope
  ! interpol_type=2 linear interpolation with Monotonized Central slope
  ! The gravitational acceleration is also prolongated
  ! using straight injection only.
  !----------------------------------------------------------
  integer::i,j,ivar,idim,ind,ix,iy,iz

  real(dp),dimension(1:twotondim,1:3)::xc
  real(dp),dimension(1:nvector,0:twondim),save::a
  real(dp),dimension(1:nvector,1:ndim),save::w
  real(dp),dimension(1:nvector),save::ekin
  logical ,dimension(1:nvector,0:twondim),save::body

  ! Set position of cell centers relative to grid center
  do ind=1,twotondim
     iz=(ind-1)/4
     iy=(ind-1-4*iz)/2
     ix=(ind-1-2*iy-4*iz)
     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)
     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)
     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)
  end do

  ! Loop over interpolation variables
  do ivar=1,nvar

     ! Load father variable
     do j=0,twondim
        do i=1,nn 
           a(i,j)=u1(i,j,ivar)
        end do
     end do

     ! If embedded body, modify variables to enforce reflexive BC
     if(static)then
        do j=0,twondim
           do i=1,nn 
              body(i,j)=u1(i,j,npri+1) > 0.01
           end do
        end do
        do j=1,ndim
           do i=1,nn 
              if(body(i,2*j-1))then
                 u1(i,2*j-1,1:nvar)= u1(i,0,1:nvar)
                 u1(i,2*j-1,1+j   )=-u1(i,0,1+j)
              endif
              if(body(i,2*j  ))then
                 u1(i,2*j  ,1:nvar)= u1(i,0,1:nvar)
                 u1(i,2*j  ,1+j   )=-u1(i,0,1+j)
              endif
           end do
        end do
     endif

     ! Reset gradient
     w(1:nn,1:ndim)=0.0D0

     ! Compute gradient with chosen limiter
     if(interpol_type==1)call compute_limiter_minmod(a,w,nn)
     if(interpol_type==2)call compute_limiter_central(a,w,nn)

     ! If inside body, reset slopes to zero
     if(static)then
        do i=1,nn 
           if(body(i,0))w(i,1:ndim)=0.0
        end do
     endif

     ! Interpolate over children cells
     do ind=1,twotondim
        u2(1:nn,ind,ivar)=a(1:nn,0)
        do idim=1,ndim
           do i=1,nn
              u2(i,ind,ivar)=u2(i,ind,ivar)+w(i,idim)*xc(ind,idim)
           end do
        end do
     end do

  end do
  ! End loop over variables

end subroutine interpol_hydro
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine compute_limiter_minmod(a,w,nn)
  use amr_commons
  use hydro_commons
  implicit none
  integer::nn
  real(dp),dimension(1:nvector,0:twondim)::a
  real(dp),dimension(1:nvector,1:ndim)::w
  !---------------
  ! MinMod slope
  !---------------
  integer::i,idim
  real(dp)::diff_left,diff_right,minmod

  do idim=1,ndim
     do i=1,nn
        diff_left=0.5*(a(i,2*idim)-a(i,0))
        diff_right=0.5*(a(i,0)-a(i,2*idim-1))
        if(diff_left*diff_right<=0.0)then
           minmod=0.0
        else
           minmod=MIN(ABS(diff_left),ABS(diff_right)) &
                &   *diff_left/ABS(diff_left)
        end if
        w(i,idim)=minmod
     end do
  end do

end subroutine compute_limiter_minmod
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine compute_limiter_central(a,w,nn)
  use amr_commons
  use hydro_commons
  implicit none
  integer::nn
  real(dp),dimension(1:nvector,0:twondim)::a
  real(dp),dimension(1:nvector,1:ndim)::w
  !---------------------------
  ! Monotonized Central slope
  !---------------------------
  integer::i,j,idim,ind,ix,iy,iz
  real(dp),dimension(1:twotondim,1:3)::xc
  real(dp)::xxc
  real(dp),dimension(1:nvector,1:twotondim),save::ac
  real(dp),dimension(1:nvector),save::corner,kernel,diff_corner,diff_kernel
  real(dp),dimension(1:nvector),save::max_limiter,min_limiter,limiter

  ! Set position of cell centers relative to grid center
  do ind=1,twotondim
     iz=(ind-1)/4
     iy=(ind-1-4*iz)/2
     ix=(ind-1-2*iy-4*iz)
     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)
     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)
     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)
  end do

  ! Second order central slope
  do idim=1,ndim
     do i=1,nn
        w(i,idim)=0.25D0*(a(i,2*idim)-a(i,2*idim-1))
     end do
  end do

  ! Compute corner interpolated values
  do ind=1,twotondim
     do i=1,nn
        ac(i,ind)=a(i,0)
     end do
  end do
  do idim=1,ndim
     do ind=1,twotondim
        xxc = xc(ind,idim)
        do i=1,nn
           corner(i)=ac(i,ind)+2.D0*w(i,idim)*xxc
        end do
        do i=1,nn
           ac(i,ind)=corner(i)
        end do
     end do
  end do

  ! Compute max of corners
  do i=1,nn
     corner(i)=ac(i,1)
  end do
  do j=2,twotondim
     do i=1,nn
        corner(i)=MAX(corner(i),ac(i,j))
     end do
  end do

  ! Compute max of gradient kernel
  do i=1,nn
     kernel(i)=a(i,1)
  end do
  do j=2,twondim
     do i=1,nn
        kernel(i)=MAX(kernel(i),a(i,j))
     end do
  end do

  ! Compute differences
  do i=1,nn
     diff_kernel(i)=a(i,0)-kernel(i)
     diff_corner(i)=a(i,0)-corner(i)
  end do

  ! Compute max_limiter
  max_limiter=0.0D0
  do i=1,nn
     if(diff_kernel(i)*diff_corner(i) > 0.0D0)then
        max_limiter(i)=MIN(1.0_dp,diff_kernel(i)/diff_corner(i))
     end if
  end do

  ! Compute min of corners
  do i=1,nn
     corner(i)=ac(i,1)
  end do
  do j=2,twotondim
     do i=1,nn
        corner(i)=MIN(corner(i),ac(i,j))
     end do
  end do

  ! Compute min of gradient kernel
  do i=1,nn
     kernel(i)=a(i,1)
  end do
  do j=2,twondim
     do i=1,nn
        kernel(i)=MIN(kernel(i),a(i,j))
     end do
  end do

  ! Compute differences
  do i=1,nn
     diff_kernel(i)=a(i,0)-kernel(i)
     diff_corner(i)=a(i,0)-corner(i)
  end do

  ! Compute max_limiter
  min_limiter=0.0D0
  do i=1,nn
     if(diff_kernel(i)*diff_corner(i) > 0.0D0)then
        min_limiter(i)=MIN(1.0_dp,diff_kernel(i)/diff_corner(i))
     end if
  end do

  ! Compute limiter
  do i=1,nn
     limiter(i)=MIN(min_limiter(i),max_limiter(i))
  end do

  ! Correct gradient with limiter
  do idim=1,ndim
     do i=1,nn
        w(i,idim)=w(i,idim)*limiter(i)
     end do
  end do

end subroutine compute_limiter_central
../patch/multimat/output_hydro.f90
subroutine backup_hydro(filename, filename_desc)
  use amr_commons
  use hydro_commons
  use dump_utils, only : dump_header_info, generic_dump, dim_keys
  use mpi_mod
  implicit none
#ifndef WITHOUTMPI
  integer :: dummy_io, info2
#endif

  character(len=80), intent(in) :: filename, filename_desc

  integer :: i, ivar, ncache, ind, ilevel, igrid, iskip, istart, ibound
  integer :: unit_out, unit_info
  integer, allocatable, dimension(:) :: ind_grid
  real(dp), allocatable, dimension(:) :: xdp
  character(LEN = 5) :: nchar
  character(LEN = 80) :: fileloc
  integer, parameter :: tag = 1121
#if NENER > 0
  integer :: irad
#endif
  logical :: dump_info_flag
  integer :: info_var_count
  integer :: idim,imat
  character(len=100) :: field_name
  real(dp)::dtot,ekin,erad
  real(dp),dimension(1:nvector,1:nmat),save::ff,gg,kk_mat
  real(dp),dimension(1:nvector,1:npri),save::qq
  real(dp),dimension(1:nvector),save::pp,cc,kk_hat

  if (verbose) write(*,*)'Entering backup_hydro'

  call title(myid, nchar)
  fileloc = TRIM(filename)//TRIM(nchar)

  ! Wait for the token
#ifndef WITHOUTMPI
  if (IOGROUPSIZE > 0) then
     if (mod(myid-1, IOGROUPSIZE) /= 0) then
        call MPI_RECV(dummy_io, 1, MPI_INTEGER, myid-1-1, tag,&
             & MPI_COMM_WORLD, MPI_STATUS_IGNORE, info2)
     end if
  end if
#endif

  open(newunit=unit_out, file=fileloc, form='unformatted')

  if (myid == 1) then
     open(newunit=unit_info, file=filename_desc, form='formatted')
     call dump_header_info(unit_info)
     info_var_count = 1
     dump_info_flag = .true.
  else
     dump_info_flag = .false.
  end if

  write(unit_out) ncpu
  write(unit_out) nvar
  write(unit_out) ndim
  write(unit_out) nlevelmax
  write(unit_out) nboundary
  write(unit_out) gamma
  do ilevel = 1, nlevelmax
     do ibound = 1, nboundary+ncpu
        if (ibound <= ncpu) then
           ncache = numbl(ibound, ilevel)
           istart = headl(ibound, ilevel)
        else
           ncache = numbb(ibound-ncpu, ilevel)
           istart = headb(ibound-ncpu, ilevel)
        end if
        write(unit_out) ilevel
        write(unit_out) ncache
        if (ncache > 0) then
           allocate(ind_grid(1:ncache), xdp(1:ncache))
           ! Loop over level grids
           igrid = istart
           do i = 1, ncache
              ind_grid(i) = igrid
              igrid = next(igrid)
           end do
           ! Loop over cells
           do ind = 1, twotondim
              iskip = ncoarse+(ind-1)*ngridmax
              do ivar = 1, ndim+1
                 if (ivar == 1) then
                    ! Write total density
                    do i = 1, ncache
                       xdp(i) = uold(ind_grid(i)+iskip, 1)
                    end do
                    field_name = 'density'
                 else if (ivar >= 2 .and. ivar <= ndim+1) then
                    ! Write velocity field
                    do i = 1, ncache
                       xdp(i) = uold(ind_grid(i)+iskip, ivar)/max(uold(ind_grid(i)+iskip, 1), smallr)
                    end do
                    field_name = 'velocity_' // dim_keys(ivar - 1)
                 end if
                 call generic_dump(field_name, info_var_count, xdp, unit_out, dump_info_flag, unit_info)
              end do
#if NENER > 0
              ! Write non-thermal pressures
              do ivar = ndim+3, ndim+2+nener
                 do i = 1, ncache
                    xdp(i) = (gamma_rad(ivar-ndim-2)-1d0)*uold(ind_grid(i)+iskip, ivar)
                 end do
                 write(field_name, '('non_thermal_energy_', i0.2)') ivar-3
                 call generic_dump(field_name, info_var_count, xdp, unit_out, dump_info_flag, unit_info)
              end do
#endif
              ! Write thermal pressure
              do i = 1, ncache
                 dtot=max(uold(ind_grid(i)+iskip,1),smallr)
                 do imat=1,nmat
                    ff(1,imat)=uold(ind_grid(i)+iskip,imat+nener+npri)
                    gg(1,imat)=uold(ind_grid(i)+iskip,imat+nener+npri+nmat)
                 end do
                 qq(1,1)=dtot
                 ekin=0.0
                 do idim=1,ndim
                    qq(1,idim+1)=uold(ind_grid(i)+iskip,idim+1)/dtot
                    ekin=ekin+0.5d0*qq(1,idim+1)**2
                 end do
                 erad=00
#if NENER > 0
                 do irad = 1,nener
                    erad=erad+uold(ind_grid(i)+iskip,ndim+2+irad)
                 end do
#endif
                 qq(1,npri)=uold(ind_grid(i)+iskip,npri)-dtot*ekin-erad
                 call eos(ff,gg,qq,pp,cc,kk_mat,kk_hat,1)
                 xdp(i)=pp(1)       ! Pressure
              end do
              field_name = 'pressure'
              call generic_dump(field_name, info_var_count, xdp, unit_out, dump_info_flag, unit_info)
              ! Write volume fractions
              do imat = 1,nmat
                 ivar = ndim+2+nener+imat
                 do i = 1, ncache
                    xdp(i) = uold(ind_grid(i)+iskip,ivar)
                 end do
                 write(field_name, '('vol_frac_', i0.2)') imat
                 call generic_dump(field_name, info_var_count, xdp, unit_out, dump_info_flag, unit_info)
              end do
              ! Write true density
              do imat = 1,nmat
                 ivar = ndim+2+nener+nmat+imat
                 do i = 1, ncache
                    xdp(i) = uold(ind_grid(i)+iskip,ivar)
                 end do
                 write(field_name, '('true_dens_', i0.2)') imat
                 call generic_dump(field_name, info_var_count, xdp, unit_out, dump_info_flag, unit_info)
              end do
              ! We did one output, deactivate dumping of variables
              dump_info_flag = .false.
           end do
           deallocate(ind_grid, xdp)

        end if
     end do
  end do
  close(unit_out)

  if (myid == 1) close(unit_info)
  ! Send the token
#ifndef WITHOUTMPI
  if (IOGROUPSIZE > 0) then
     if (mod(myid, IOGROUPSIZE) /= 0 .and.(myid .lt. ncpu)) then
        dummy_io = 1
        call MPI_SEND(dummy_io, 1, MPI_INTEGER, myid-1+1, tag, &
             & MPI_COMM_WORLD, info2)
     end if
  end if
#endif

end subroutine backup_hydro






../patch/multimat/read_hydro_params.f90
subroutine read_hydro_params(nml_ok)
  use amr_commons
  use hydro_commons
  use mpi_mod
  implicit none
  logical::nml_ok
  !--------------------------------------------------
  ! Local variables  
  !--------------------------------------------------
  integer::i,idim,imat
  integer ,dimension(1:MAXBOUND)::bound_type
  real(dp)::scale,dtot,ftot
  real(dp),dimension(1:nvector,1:npri)::q
  real(dp),dimension(1:nvector,1:nmat)::f,g,kappa_mat
  real(dp),dimension(1:nvector)::ek_bound,eint,cs,kappa_hat

  !--------------------------------------------------
  ! Namelist definitions
  !--------------------------------------------------
  namelist/init_params/initfile,nregion,region_type &
       & ,x_center,y_center,z_center & 
       & ,length_x,length_y,length_z,exp_region &
       & ,d1_region,d2_region,d3_region,d4_region &
       & ,f1_region,f2_region,f3_region,f4_region &
       & ,u_region,v_region,w_region,p_region
  namelist/hydro_params/courant_factor,smallr,smallc,smallf,slope_type,scheme,eos_name
  namelist/refine_params/x_refine,y_refine,z_refine,r_refine,a_refine,b_refine,exp_refine &
       & ,m_refine,mass_sph,err_grad_f,err_grad_d,err_grad_p,err_grad_u &
       & ,floor_f,floor_d,floor_u,floor_p &
       & ,interpol_var,interpol_type
  namelist/boundary_params/nboundary,bound_type &
       & ,ibound_min,ibound_max,jbound_min,jbound_max,kbound_min,kbound_max &
       & ,d1_bound,d2_bound,d3_bound,d4_bound &
       & ,f1_bound,f2_bound,f3_bound,f4_bound &
       & ,u_bound,v_bound,w_bound,p_bound
  namelist/material_params/eos_type,eos_file,eos_params

  ! Read namelist file
  rewind(1)
  read(1,NML=init_params)
  rewind(1)
  read(1,NML=material_params)
  rewind(1)
  if(nlevelmax>levelmin)read(1,NML=refine_params)
  rewind(1)
  if(hydro)read(1,NML=hydro_params)
  rewind(1)
  read(1,NML=boundary_params,END=103)
  simple_boundary=.true.
  goto 104
103 simple_boundary=.false.
104 if(nboundary>MAXBOUND)then
    write(*,*) 'Error: nboundary>MAXBOUND'
    call clean_stop
  end if
  rewind(1)
  !-------------------------------------------------
  ! This section deals with hydro boundary conditions
  !-------------------------------------------------
  if(simple_boundary.and.nboundary==0)then
     simple_boundary=.false.
  endif

  if (simple_boundary)then

     ! Compute new coarse grid boundaries
     do i=1,nboundary
        if(ibound_min(i)*ibound_max(i)==1.and.ndim>0)then
           nx=nx+1
           if(ibound_min(i)==-1)then
              icoarse_min=icoarse_min+1
              icoarse_max=icoarse_max+1
           end if
        end if
     end do
     do i=1,nboundary
        if(jbound_min(i)*jbound_max(i)==1.and.ndim>1)then
           ny=ny+1
           if(jbound_min(i)==-1)then
              jcoarse_min=jcoarse_min+1
              jcoarse_max=jcoarse_max+1
           end if
        end if
     end do
     do i=1,nboundary
        if(kbound_min(i)*kbound_max(i)==1.and.ndim>2)then
           nz=nz+1
           if(kbound_min(i)==-1)then
              kcoarse_min=kcoarse_min+1
              kcoarse_max=kcoarse_max+1
           end if
        end if
     end do

     ! Compute boundary geometry
     do i=1,nboundary
        if(ibound_min(i)*ibound_max(i)==1.and.ndim>0)then
           if(ibound_min(i)==-1)then
              ibound_min(i)=icoarse_min+ibound_min(i)
              ibound_max(i)=icoarse_min+ibound_max(i)
              if(bound_type(i)==1)boundary_type(i)=1
              if(bound_type(i)==2)boundary_type(i)=11
              if(bound_type(i)==3)boundary_type(i)=21
           else
              ibound_min(i)=icoarse_max+ibound_min(i)
              ibound_max(i)=icoarse_max+ibound_max(i)
              if(bound_type(i)==1)boundary_type(i)=2
              if(bound_type(i)==2)boundary_type(i)=12
              if(bound_type(i)==3)boundary_type(i)=22
           end if
           if(ndim>1)jbound_min(i)=jcoarse_min+jbound_min(i)
           if(ndim>1)jbound_max(i)=jcoarse_max+jbound_max(i)
           if(ndim>2)kbound_min(i)=kcoarse_min+kbound_min(i)
           if(ndim>2)kbound_max(i)=kcoarse_max+kbound_max(i)
        else if(jbound_min(i)*jbound_max(i)==1.and.ndim>1)then
           ibound_min(i)=icoarse_min+ibound_min(i)
           ibound_max(i)=icoarse_max+ibound_max(i)
           if(jbound_min(i)==-1)then
              jbound_min(i)=jcoarse_min+jbound_min(i)
              jbound_max(i)=jcoarse_min+jbound_max(i)
              if(bound_type(i)==1)boundary_type(i)=3
              if(bound_type(i)==2)boundary_type(i)=13
              if(bound_type(i)==3)boundary_type(i)=23
           else
              jbound_min(i)=jcoarse_max+jbound_min(i)
              jbound_max(i)=jcoarse_max+jbound_max(i)
              if(bound_type(i)==1)boundary_type(i)=4
              if(bound_type(i)==2)boundary_type(i)=14
              if(bound_type(i)==3)boundary_type(i)=24
           end if
           if(ndim>2)kbound_min(i)=kcoarse_min+kbound_min(i)
           if(ndim>2)kbound_max(i)=kcoarse_max+kbound_max(i)
        else if(kbound_min(i)*kbound_max(i)==1.and.ndim>2)then
           ibound_min(i)=icoarse_min+ibound_min(i)
           ibound_max(i)=icoarse_max+ibound_max(i)
           jbound_min(i)=jcoarse_min+jbound_min(i)
           jbound_max(i)=jcoarse_max+jbound_max(i)
           if(kbound_min(i)==-1)then
              kbound_min(i)=kcoarse_min+kbound_min(i)
              kbound_max(i)=kcoarse_min+kbound_max(i)
              if(bound_type(i)==1)boundary_type(i)=5
              if(bound_type(i)==2)boundary_type(i)=15
              if(bound_type(i)==3)boundary_type(i)=25
           else
              kbound_min(i)=kcoarse_max+kbound_min(i)
              kbound_max(i)=kcoarse_max+kbound_max(i)
              if(bound_type(i)==1)boundary_type(i)=6
              if(bound_type(i)==2)boundary_type(i)=16
              if(bound_type(i)==3)boundary_type(i)=26
           end if
        end if
     end do
     do i=1,nboundary
        ! Check for errors
        if( (ibound_min(i)<0.or.ibound_max(i)>(nx-1)) .and. (ndim>0) )then
           if(myid==1)write(*,*)'Error in the namelist'
           if(myid==1)write(*,*)'Check boundary conditions along X direction',i
           nml_ok=.false.
        end if
        if( (jbound_min(i)<0.or.jbound_max(i)>(ny-1)) .and. (ndim>1) )then
           if(myid==1)write(*,*)'Error in the namelist'
           if(myid==1)write(*,*)'Check boundary conditions along Y direction',i
           nml_ok=.false.
        end if
        if( (kbound_min(i)<0.or.kbound_max(i)>(nz-1)) .and. (ndim>2) )then
           if(myid==1)write(*,*)'Error in the namelist'
           if(myid==1)write(*,*)'Check boundary conditions along Z direction',i
           nml_ok=.false.
        end if
     end do
  end if

  !--------------------------------------------------
  ! Compute boundary conservative variables
  !--------------------------------------------------
  do i=1,nboundary
     imat=1
     f(i,imat)=max(f1_bound(i),smallf)
     g(i,imat)=max(d1_bound(i),smallr)
     if(nmat>1)then
        imat=imat+1
        f(i,imat)=max(f2_bound(i),smallf)
        g(i,imat)=max(d2_bound(i),smallr)
     end if
     if(nmat>2)then
        imat=imat+1
        f(i,imat)=max(f3_bound(i),smallf)
        g(i,imat)=max(d3_bound(i),smallr)
     end if
     if(nmat>3)then
        imat=imat+1
        f(i,imat)=max(f4_bound(i),smallf)
        g(i,imat)=max(d4_bound(i),smallr)
     end if
     ! Normalize volume fraction
     ftot=1d-15
     do imat=1,nmat
        ftot=ftot+f(i,imat)
     end do
     do imat=1,nmat
        f(i,imat)=f(i,imat)/ftot
     end do
     ! Compute total density
     q(i,1)=0.0
     do imat=1,nmat
        q(i,1)=q(i,1)+f(i,imat)*g(i,imat)
     end do
     ! Compute velocity
     q(i,2)=u_bound(i)
#if NDIM>1
     q(i,3)=v_bound(i)
#endif
#if NDIM>2
     q(i,4)=w_bound(i)
#endif
     q(i,npri)=p_bound(i)
  end do

  if(nboundary>0)call eosinv(f,g,q,eint,cs,kappa_mat,kappa_hat,nboundary)

  ! density -> density
  do i=1,nboundary
     boundary_var(i,1)=q(i,1)
  end do
  ! velocity -> momentum
  ek_bound(1:nboundary)=0.0
  do idim=1,ndim
     do i=1,nboundary
        boundary_var(i,idim+1)=q(i,1)*q(i,idim+1)
        ek_bound(i)=ek_bound(i)+0.5*q(i,idim+1)**2
     end do
  end do
  ! total energy
  do i=1,nboundary
     boundary_var(i,npri)=eint(i)+q(i,1)*ek_bound(i)
  end do
  ! volume fraction
  do imat=1,nmat
     do i=1,nboundary
        boundary_var(i,imat+npri)=f(i,imat)
     end do
  end do
  ! fluid density
  do imat=1,nmat
     do i=1,nboundary
        boundary_var(i,imat+npri+nmat)=g(i,imat)
     end do
  end do

end subroutine read_hydro_params

../patch/multimat/umuscl.f90
! ---------------------------------------------------------------
!  UNSPLIT     Unsplit second order Godunov integrator for 
!              real gases (arbitrary EOS) dynamics using
!              MUSCL-HANCOCK scheme
!              with various slope limiters.
!
!  inputs/outputs
!  uin         => (const)  input state
!  gravin      => (const)  input gravitational acceleration
!  iu1,iu2     => (const)  first and last index of input array,
!  ju1,ju2     => (const)  cell centered,    
!  ku1,ku2     => (const)  including buffer cells.
!  flux       <=  (modify) return fluxes in the 3 coord directions
!  if1,if2     => (const)  first and last index of output array,
!  jf1,jf2     => (const)  edge centered,
!  kf1,kf2     => (const)  for active cells only.
!  dx,dy,dz    => (const)  (dx,dy,dz)
!  dt          => (const)  time step
!  ngrid       => (const)  number of sub-grids
!  ndim        => (const)  number of dimensions
! ----------------------------------------------------------------
subroutine unsplit(uin,gravin,rin,flux,tmp,dx,dy,dz,dt,ngrid)
  use amr_parameters
  use const
  use hydro_parameters
  implicit none 

  integer ::ngrid
  real(dp)::dx,dy,dz,dt

  ! Input states
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar)::uin 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:ndim)::gravin 
  real(dp),dimension(1:nvector,iu1:iu2)::rin 

  ! Output fluxes
  real(dp),dimension(1:nvector,if1:if2,jf1:jf2,kf1:kf2,1:nvar,1:ndim)::flux
  real(dp),dimension(1:nvector,if1:if2,jf1:jf2,kf1:kf2,1:2   ,1:ndim)::tmp 

  ! Primitive variables
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri),save::qin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat),save::fin 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat),save::gin 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2       ),save::cin 

  ! Slopes
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim),save::dq
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim),save::df
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim),save::dg

  ! Left and right state arrays
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim),save::qm
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim),save::qp
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim),save::fm
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim),save::fp
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim),save::gm
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim),save::gp
  
  ! Intermediate fluxes
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar),save::fx
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:2   ),save::tx

  ! Local scalar variables
  integer::i,j,k,l,ivar,ir,ie,imat,iu
  integer::ilo,ihi,jlo,jhi,klo,khi
  real(dp),dimension(1:nvector)::ekin,flux_dtot

  ilo=MIN(1,iu1+2); ihi=MAX(1,iu2-2)
  jlo=MIN(1,ju1+2); jhi=MAX(1,ju2-2)
  klo=MIN(1,ku1+2); khi=MAX(1,ku2-2)

  ! Translate to primitive variable (d,u,P) volume and mass fraction (f,g)
  call ctoprim(uin,qin,fin,gin,cin,gravin,dt,ngrid)

  ! Compute TVD slopes
  call qslope(qin,dq,dx,dt,ngrid)
  call fslope(fin,df,qin,dx,dt,ngrid)
  call fslope(gin,dg,qin,dx,dt,ngrid)

  ! Compute 3D traced-states in all three directions
#if NDIM==1
     call trace1d (qin,fin,gin,rin,dq,df,dg,cin,qm,qp,fm,fp,gm,gp,dx      ,dt,ngrid)
#endif
#if NDIM==2
     call trace2d (qin,fin,gin,rin,dq,df,dg,cin,qm,qp,fm,fp,gm,gp,dx,dy   ,dt,ngrid)
#endif
#if NDIM==3
     call trace3d (qin,fin,gin,    dq,df,dg,cin,qm,qp,fm,fp,gm,gp,dx,dy,dz,dt,ngrid)
#endif

  ! Compute 1D flux in X direction
  call cmpgdnv(fm,gm,qm,iu1+1,iu2+1,ju1  ,ju2  ,ku1  ,ku2  , &
       &       fp,gp,qp,iu1  ,iu2  ,ju1  ,ju2  ,ku1  ,ku2  , cin, &
       &          fx,tx,if1  ,if2  ,jlo  ,jhi  ,klo  ,khi  , 2,3,4,ngrid)
  ! Save flux in output array
  do i=if1,if2
  do j=jlo,jhi
  do k=klo,khi
     do ivar=1,nvar
        do l=1,ngrid
           flux(l,i,j,k,ivar,1)=fx(l,i,j,k,ivar)*dt/dx
        end do
     end do
     do ivar=1,2
        do l=1,ngrid
           tmp (l,i,j,k,ivar,1)=tx(l,i,j,k,ivar)*dt/dx
        end do
     end do
  end do
  end do
  end do

  ! Solve for 1D flux in Y direction
#if NDIM>1
  call cmpgdnv(fm,gm,qm,iu1  ,iu2  ,ju1+1,ju2+1,ku1  ,ku2  , &
       &       fp,gp,qp,iu1  ,iu2  ,ju1  ,ju2  ,ku1  ,ku2  , cin, &
       &          fx,tx,ilo  ,ihi  ,jf1  ,jf2  ,klo  ,khi  , 3,2,4,ngrid)
  ! Save flux in output array
  do i=ilo,ihi
  do j=jf1,jf2
  do k=klo,khi
     do ivar=1,nvar
        do l=1,ngrid
           flux(l,i,j,k,ivar,2)=fx(l,i,j,k,ivar)*dt/dy
        end do
     end do
     do ivar=1,2
        do l=1,ngrid
           tmp (l,i,j,k,ivar,2)=tx(l,i,j,k,ivar)*dt/dy
        end do
     end do
  end do
  end do
  end do
#endif

  ! Solve for 1D flux in Z direction
#if NDIM>2
  call cmpgdnv(fm,gm,qm,iu1  ,iu2  ,ju1  ,ju2  ,ku1+1,ku2+1, &
       &       fp,gp,qp,iu1  ,iu2  ,ju1  ,ju2  ,ku1  ,ku2  , cin, &
       &          fx,tx,ilo  ,ihi  ,jlo  ,jhi  ,kf1  ,kf2  , 4,2,3,ngrid)
  ! Save flux in output array
  do i=ilo,ihi
  do j=jlo,jhi
  do k=kf1,kf2
     do ivar=1,nvar
        do l=1,ngrid
           flux(l,i,j,k,ivar,3)=fx(l,i,j,k,ivar)*dt/dz
        end do
     end do
     do ivar=1,2
        do l=1,ngrid
           tmp (l,i,j,k,ivar,3)=tx(l,i,j,k,ivar)*dt/dz
        end do
     end do
  end do
  end do
  end do
#endif

end subroutine unsplit
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine ctoprim(uin,q,f,g,c,gravin,dt,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none
  ! u: f_k, f_k d_k, d u, E
  ! q: rho_k, u, P
  integer ::ngrid
  real(dp)::dt
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar)::uin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:ndim)::gravin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri)::q
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat)::f,g
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2)::c

  integer ::i, j, k, l, n, idim, imat
  real(dp),dimension(1:nvector),save::dtot,ekin,cc,pp,kappa_hat
  real(dp),dimension(1:nvector,1:npri),save::qq
  real(dp),dimension(1:nvector,1:nmat),save::ff,gg,kappa_mat

  ! Convert to primitive variable
  do k = ku1, ku2
  do j = ju1, ju2
  do i = iu1, iu2
     
     ! Volume fraction and fluid density
     do imat = 1,nmat
        do l = 1,ngrid
           ff(l,imat) = uin(l,i,j,k,imat+npri)
           gg(l,imat) = uin(l,i,j,k,imat+npri+nmat)
        end do
     end do
     
     ! Compute total density
     do l = 1,ngrid
        qq(l,1) = uin(l,i,j,k,1)
     end do
     
     ! Compute velocity and specific kinetic energy
     ekin(1:ngrid)=0.0
     do idim = 1,ndim
        do l = 1,ngrid
           qq(l,idim+1) = uin(l,i,j,k,idim+1)/qq(l,1)
           ekin(l) = ekin(l) + half*qq(l,idim+1)**2
        end do
     end do
     
     ! Compute total internal energy
     do l = 1,ngrid
        qq(l,npri) = uin(l,i,j,k,npri) - qq(l,1)*ekin(l)
     end do

     ! Call eos routine
     call eos(ff,gg,qq,pp,cc,kappa_mat,kappa_hat,ngrid)

     ! Pressure overwrites internal energy
     qq(1:ngrid,npri)=pp(1:ngrid)

     ! Save in output arrays
     q(1:ngrid,i,j,k,1:npri)=qq(1:ngrid,1:npri)
     f(1:ngrid,i,j,k,1:nmat)=ff(1:ngrid,1:nmat)
     g(1:ngrid,i,j,k,1:nmat)=gg(1:ngrid,1:nmat)
     c(1:ngrid,i,j,k       )=cc(1:ngrid)

     ! Gravity predictor step
     do idim = 1,ndim
        q(1:ngrid,i,j,k,idim+1) = q(1:ngrid,i,j,k,idim+1) &
             &             + gravin(1:ngrid,i,j,k,idim)*dt*half
     end do
     
  end do
  end do
  end do
 
end subroutine ctoprim
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine trace1d(qin,fin,gin,rin,dq,df,dg,cin,qm,qp,fm,fp,gm,gp,dx,dt,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  integer ::ngrid
  real(dp)::dx, dt

  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::dq 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::qm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::qp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri)::qin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::df
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::fm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::fp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat)::fin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::dg
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::gm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::gp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat)::gin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2)::cin
  real(dp),dimension(1:nvector,iu1:iu2)::rin

  ! Local variables
  integer ::i, j, k, l, n, imat
  integer ::ilo,ihi,jlo,jhi,klo,khi
  integer ::ir, iu, ip
  real(dp)::dtdx, r, u, p, drx, dux, dpx, sr0, su0, sp0, csq, curvilin
  real(dp),dimension(1:nmat)::f,g,dfx,dgx,sf0,sg0
  
  dtdx = dt/dx

  ilo=MIN(1,iu1+1); ihi=MAX(1,iu2-1)
  jlo=MIN(1,ju1+1); jhi=MAX(1,ju2-1)
  klo=MIN(1,ku1+1); khi=MAX(1,ku2-1)
  ir=1; iu=2; ip=3

  do k = klo, khi
  do j = jlo, jhi
  do i = ilo, ihi

     do l = 1, ngrid
        
        ! Cell centered values
        do imat   = 1,nmat
        f(imat)   = fin(l,i,j,k,imat)
        g(imat)   = gin(l,i,j,k,imat)
        end do
        r         = qin(l,i,j,k,ir)
        u         = qin(l,i,j,k,iu)
        p         = qin(l,i,j,k,ip)
        csq       = cin(l,i,j,k)**2
        
        ! Radius
        curvilin  = dble(geom-1)*u*dx/(rin(l,i)+1d-15*dx)

        ! TVD slopes in X direction
        do imat   = 1,nmat
        dfx(imat) = df(l,i,j,k,imat,1)
        dgx(imat) = dg(l,i,j,k,imat,1)
        end do
        drx       = dq(l,i,j,k,ir  ,1)
        dux       = dq(l,i,j,k,iu  ,1)
        dpx       = dq(l,i,j,k,ip  ,1)
        
        ! Source terms (including transverse derivatives and geometrical terms)
        do imat   = 1,nmat
        sf0(imat) = -u*dfx(imat)
        sg0(imat) = -u*dgx(imat)
        end do
        sr0       = -u*drx       - (dux)*r      - curvilin*r
        su0       = -u*dux       - (dpx)/r
        sp0       = -u*dpx       - (dux)*r*csq  - curvilin*r*csq
        
        ! Right state
        do imat = 1,nmat
        fp(l,i,j,k,imat,1) = f(imat)-half*dfx(imat)+sf0(imat)*dtdx*half
        gp(l,i,j,k,imat,1) = g(imat)-half*dgx(imat)+sg0(imat)*dtdx*half
        end do
        qp(l,i,j,k,ir  ,1) = r      -half*drx      +sr0      *dtdx*half
        qp(l,i,j,k,iu  ,1) = u      -half*dux      +su0      *dtdx*half
        qp(l,i,j,k,ip  ,1) = p      -half*dpx      +sp0      *dtdx*half
        
        ! Left state
        do imat = 1,nmat
        fm(l,i,j,k,imat,1) = f(imat)+half*dfx(imat)+sf0(imat)*dtdx*half
        gm(l,i,j,k,imat,1) = g(imat)+half*dgx(imat)+sg0(imat)*dtdx*half
        end do
        qm(l,i,j,k,ir  ,1) = r      +half*drx      +sr0      *dtdx*half
        qm(l,i,j,k,iu  ,1) = u      +half*dux      +su0      *dtdx*half
        qm(l,i,j,k,ip  ,1) = p      +half*dpx      +sp0      *dtdx*half
        
     end do

  end do
  end do
  end do

end subroutine trace1d
!###########################################################
!###########################################################
!###########################################################
!###########################################################
#if NDIM>1
subroutine trace2d(qin,fin,gin,rin,dq,df,dg,cin,qm,qp,fm,fp,gm,gp,dx,dy,dt,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  integer ::ngrid
  real(dp)::dx, dy, dt

  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::dq 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::qm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::qp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri)::qin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::df
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::fm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::fp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat)::fin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::dg
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::gm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::gp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat)::gin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2)::cin
  real(dp),dimension(1:nvector,iu1:iu2)::rin

  ! Local variables
  integer ::i, j, k, l, n, imat
  integer ::ilo,ihi,jlo,jhi,klo,khi
  integer ::ir, iu, iv, ip
  real(dp)::dtdx, dtdy, r, u, v, p
  real(dp)::drx, dux, dvx, dpx
  real(dp)::dry, duy, dvy, dpy
  real(dp)::sr0, su0, sv0, sp0, csq
  real(dp),dimension(1:nmat)::f,g,dfx,dgx,dfy,dgy,sf0,sg0
  
  dtdx = dt/dx
  dtdy = dt/dy
  ilo=MIN(1,iu1+1); ihi=MAX(1,iu2-1)
  jlo=MIN(1,ju1+1); jhi=MAX(1,ju2-1)
  klo=MIN(1,ku1+1); khi=MAX(1,ku2-1)
  ir=1; iu=2; iv=3; ip=4

  do k = klo, khi
  do j = jlo, jhi
  do i = ilo, ihi
     
     do l = 1, ngrid
        
        ! Cell centered values
        do imat   = 1,nmat
        f(imat)   = fin(l,i,j,k,imat)
        g(imat)   = gin(l,i,j,k,imat)
        end do
        r         = qin(l,i,j,k,ir)
        u         = qin(l,i,j,k,iu)
        v         = qin(l,i,j,k,iv)
        p         = qin(l,i,j,k,ip)
        csq       = cin(l,i,j,k)**2
        
        ! TVD slopes in all directions
        do imat   = 1,nmat
        dfx(imat) = df(l,i,j,k,imat,1)
        dgx(imat) = dg(l,i,j,k,imat,1)
        end do
        drx       = dq(l,i,j,k,ir,1)
        dux       = dq(l,i,j,k,iu,1)
        dvx       = dq(l,i,j,k,iv,1)
        dpx       = dq(l,i,j,k,ip,1)
        do imat   = 1,nmat
        dfy(imat) = df(l,i,j,k,imat,2)
        dgy(imat) = dg(l,i,j,k,imat,2)
        end do
        dry       = dq(l,i,j,k,ir,2)
        duy       = dq(l,i,j,k,iu,2)
        dvy       = dq(l,i,j,k,iv,2)
        dpy       = dq(l,i,j,k,ip,2)
        
        ! source terms (with transverse derivatives)
        do imat   = 1,nmat
        sf0(imat) = -u*dfx(imat)-v*dfy(imat)
        sg0(imat) = -u*dgx(imat)-v*dgy(imat)
        end do
        sr0       = -u*drx      -v*dry      -(dux+dvy)*r
        su0       = -u*dux      -v*duy      -(dpx    )/r
        sv0       = -u*dvx      -v*dvy      -(dpy    )/r
        sp0       = -u*dpx      -v*dpy      -(dux+dvy)*r*csq
        
        ! Right state at left interface
        do imat = 1,nmat
        fp(l,i,j,k,imat,1) = f(imat)-half*dfx(imat)+sf0(imat)*dtdx*half
        gp(l,i,j,k,imat,1) = g(imat)-half*dgx(imat)+sg0(imat)*dtdx*half
        end do
        qp(l,i,j,k,ir  ,1) = r      -half*drx      +sr0      *dtdx*half
        qp(l,i,j,k,iu  ,1) = u      -half*dux      +su0      *dtdx*half
        qp(l,i,j,k,iv  ,1) = v      -half*dvx      +sv0      *dtdx*half
        qp(l,i,j,k,ip  ,1) = p      -half*dpx      +sp0      *dtdx*half
        
        ! Left state at right interface
        do imat = 1,nmat
        fm(l,i,j,k,imat,1) = f(imat)+half*dfx(imat)+sf0(imat)*dtdx*half
        gm(l,i,j,k,imat,1) = g(imat)+half*dgx(imat)+sg0(imat)*dtdx*half
        end do
        qm(l,i,j,k,ir  ,1) = r      +half*drx      +sr0      *dtdx*half
        qm(l,i,j,k,iu  ,1) = u      +half*dux      +su0      *dtdx*half
        qm(l,i,j,k,iv  ,1) = v      +half*dvx      +sv0      *dtdx*half
        qm(l,i,j,k,ip  ,1) = p      +half*dpx      +sp0      *dtdx*half
        
        ! Top state at bottom interface
        do imat = 1,nmat
        fp(l,i,j,k,imat,2) = f(imat)-half*dfy(imat)+sf0(imat)*dtdy*half
        gp(l,i,j,k,imat,2) = g(imat)-half*dgy(imat)+sg0(imat)*dtdy*half
        end do
        qp(l,i,j,k,ir  ,2) = r      -half*dry      +sr0      *dtdy*half
        qp(l,i,j,k,iu  ,2) = u      -half*duy      +su0      *dtdy*half
        qp(l,i,j,k,iv  ,2) = v      -half*dvy      +sv0      *dtdy*half
        qp(l,i,j,k,ip  ,2) = p      -half*dpy      +sp0      *dtdy*half
        
        ! Bottom state at top interface
        do imat = 1,nmat
        fm(l,i,j,k,imat,2) = f(imat)+half*dfy(imat)+sf0(imat)*dtdy*half
        gm(l,i,j,k,imat,2) = g(imat)+half*dgy(imat)+sg0(imat)*dtdy*half
        end do
        qm(l,i,j,k,ir  ,2) = r      +half*dry      +sr0      *dtdy*half
        qm(l,i,j,k,iu  ,2) = u      +half*duy      +su0      *dtdy*half
        qm(l,i,j,k,iv  ,2) = v      +half*dvy      +sv0      *dtdy*half
        qm(l,i,j,k,ip  ,2) = p      +half*dpy      +sp0      *dtdy*half
        
     end do

  end do
  end do
  end do

end subroutine trace2d
#endif
!###########################################################
!###########################################################
!###########################################################
!###########################################################
#if NDIM>2
subroutine trace3d(qin,fin,gin,dq,df,dg,cin,qm,qp,fm,fp,gm,gp,dx,dy,dz,dt,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  integer ::ngrid
  real(dp)::dx, dy, dz, dt

  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::dq 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::qm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::qp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri)::qin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::df
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::fm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::fp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat)::fin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::dg
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::gm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::gp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat)::gin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2)::cin

  ! declare local variables
  integer ::i, j, k, l, n, imat
  integer ::ilo,ihi,jlo,jhi,klo,khi
  integer ::ir, iu, iv, iw, ip
  real(dp)::dtdx, dtdy, dtdz, r, u, v, w, p
  real(dp)::drx, dux, dvx, dwx, dpx
  real(dp)::dry, duy, dvy, dwy, dpy
  real(dp)::drz, duz, dvz, dwz, dpz
  real(dp)::sr0, su0, sv0, sw0, sp0, csq
  real(dp),dimension(1:nmat)::f,g,dfx,dgx,dfy,dgy,dfz,dgz,sf0,sg0
  
  dtdx = dt/dx
  dtdy = dt/dy
  dtdz = dt/dz
  ilo=MIN(1,iu1+1); ihi=MAX(1,iu2-1)
  jlo=MIN(1,ju1+1); jhi=MAX(1,ju2-1)
  klo=MIN(1,ku1+1); khi=MAX(1,ku2-1)
  ir=1; iu=2; iv=3; iw=4; ip=5

  do k = klo, khi
  do j = jlo, jhi
  do i = ilo, ihi

     do l = 1, ngrid
        
        ! Cell centered values
        do imat   = 1,nmat
        f(imat)   = fin(l,i,j,k,imat)
        g(imat)   = gin(l,i,j,k,imat)
        end do
        r         = qin(l,i,j,k,ir)
        u         = qin(l,i,j,k,iu)
        v         = qin(l,i,j,k,iv)
        w         = qin(l,i,j,k,iw)
        p         = qin(l,i,j,k,ip)
        csq       = cin(l,i,j,k)**2
        
        ! TVD slopes in all 3 directions
        do imat   = 1,nmat
        dfx(imat) = df(l,i,j,k,imat,1)
        dgx(imat) = dg(l,i,j,k,imat,1)
        end do
        drx       = dq(l,i,j,k,ir,1)
        dpx       = dq(l,i,j,k,ip,1)
        dux       = dq(l,i,j,k,iu,1)
        dvx       = dq(l,i,j,k,iv,1)
        dwx       = dq(l,i,j,k,iw,1)
        do imat   = 1,nmat
        dfy(imat) = df(l,i,j,k,imat,2)
        dgy(imat) = dg(l,i,j,k,imat,2)
        end do
        dry       = dq(l,i,j,k,ir,2)
        dpy       = dq(l,i,j,k,ip,2)
        duy       = dq(l,i,j,k,iu,2)
        dvy       = dq(l,i,j,k,iv,2)
        dwy       = dq(l,i,j,k,iw,2)
        do imat   = 1,nmat
        dfz(imat) = df(l,i,j,k,imat,3)
        dgz(imat) = dg(l,i,j,k,imat,3)
        end do
        drz       = dq(l,i,j,k,ir,3)
        dpz       = dq(l,i,j,k,ip,3)
        duz       = dq(l,i,j,k,iu,3)
        dvz       = dq(l,i,j,k,iv,3)
        dwz       = dq(l,i,j,k,iw,3)
        
        ! source terms (with transverse derivatives)
        do imat   = 1,nmat
        sf0(imat) = -u*dfx(imat)-v*dfy(imat)-w*dfz(imat)
        sg0(imat) = -u*dgx(imat)-v*dgy(imat)-w*dgz(imat)
        end do
        sr0       = -u*drx-v*dry-w*drz - (dux+dvy+dwz)*r
        sp0       = -u*dpx-v*dpy-w*dpz - (dux+dvy+dwz)*r*csq
        su0       = -u*dux-v*duy-w*duz - (dpx        )/r
        sv0       = -u*dvx-v*dvy-w*dvz - (dpy        )/r
        sw0       = -u*dwx-v*dwy-w*dwz - (dpz        )/r
        
        ! Right state at left interface
        do imat = 1,nmat
        fp(l,i,j,k,imat,1) = f(imat)-half*dfx(imat)+sf0(imat)*dtdx*half
        gp(l,i,j,k,imat,1) = g(imat)-half*dgx(imat)+sg0(imat)*dtdx*half
        end do
        qp(l,i,j,k,ir  ,1) = r      -half*drx      +sr0      *dtdx*half
        qp(l,i,j,k,ip  ,1) = p      -half*dpx      +sp0      *dtdx*half
        qp(l,i,j,k,iu  ,1) = u      -half*dux      +su0      *dtdx*half
        qp(l,i,j,k,iv  ,1) = v      -half*dvx      +sv0      *dtdx*half
        qp(l,i,j,k,iw  ,1) = w      -half*dwx      +sw0      *dtdx*half
        
        ! Left state at right interface
        do imat = 1,nmat
        fm(l,i,j,k,imat,1) = f(imat)+half*dfx(imat)+sf0(imat)*dtdx*half
        gm(l,i,j,k,imat,1) = g(imat)+half*dgx(imat)+sg0(imat)*dtdx*half
        end do
        qm(l,i,j,k,ir  ,1) = r      +half*drx      +sr0      *dtdx*half
        qm(l,i,j,k,ip  ,1) = p      +half*dpx      +sp0      *dtdx*half
        qm(l,i,j,k,iu  ,1) = u      +half*dux      +su0      *dtdx*half
        qm(l,i,j,k,iv  ,1) = v      +half*dvx      +sv0      *dtdx*half
        qm(l,i,j,k,iw  ,1) = w      +half*dwx      +sw0      *dtdx*half
        
        ! Top state at bottom interface
        do imat = 1,nmat
        fp(l,i,j,k,imat,2) = f(imat)-half*dfy(imat)+sf0(imat)*dtdy*half
        gp(l,i,j,k,imat,2) = g(imat)-half*dgy(imat)+sg0(imat)*dtdy*half
        end do
        qp(l,i,j,k,ir  ,2) = r      -half*dry      +sr0      *dtdy*half
        qp(l,i,j,k,ip  ,2) = p      -half*dpy      +sp0      *dtdy*half
        qp(l,i,j,k,iu  ,2) = u      -half*duy      +su0      *dtdy*half
        qp(l,i,j,k,iv  ,2) = v      -half*dvy      +sv0      *dtdy*half
        qp(l,i,j,k,iw  ,2) = w      -half*dwy      +sw0      *dtdy*half
        
        ! Bottom state at top interface
        do imat = 1,nmat
        fm(l,i,j,k,imat,2) = f(imat)+half*dfy(imat)+sf0(imat)*dtdy*half
        gm(l,i,j,k,imat,2) = g(imat)+half*dgy(imat)+sg0(imat)*dtdy*half
        end do
        qm(l,i,j,k,ir  ,2) = r      +half*dry      +sr0      *dtdy*half
        qm(l,i,j,k,ip  ,2) = p      +half*dpy      +sp0      *dtdy*half
        qm(l,i,j,k,iu  ,2) = u      +half*duy      +su0      *dtdy*half
        qm(l,i,j,k,iv  ,2) = v      +half*dvy      +sv0      *dtdy*half
        qm(l,i,j,k,iw  ,2) = w      +half*dwy      +sw0      *dtdy*half
        
        ! Back state at front interface
        do imat = 1,nmat
        fp(l,i,j,k,imat,3) = f(imat)-half*dfz(imat)+sf0(imat)*dtdz*half
        gp(l,i,j,k,imat,3) = g(imat)-half*dgz(imat)+sg0(imat)*dtdz*half
        end do
        qp(l,i,j,k,ir  ,3) = r      -half*drz      +sr0      *dtdz*half
        qp(l,i,j,k,ip  ,3) = p      -half*dpz      +sp0      *dtdz*half
        qp(l,i,j,k,iu  ,3) = u      -half*duz      +su0      *dtdz*half
        qp(l,i,j,k,iv  ,3) = v      -half*dvz      +sv0      *dtdz*half
        qp(l,i,j,k,iw  ,3) = w      -half*dwz      +sw0      *dtdz*half
        
        ! Front state at back interface
        do imat = 1,nmat
        fm(l,i,j,k,imat,3) = f(imat)+half*dfz(imat)+sf0(imat)*dtdz*half
        gm(l,i,j,k,imat,3) = g(imat)+half*dgz(imat)+sg0(imat)*dtdz*half
        end do
        qm(l,i,j,k,ir  ,3) = r      +half*drz      +sr0      *dtdz*half
        qm(l,i,j,k,ip  ,3) = p      +half*dpz      +sp0      *dtdz*half
        qm(l,i,j,k,iu  ,3) = u      +half*duz      +su0      *dtdz*half
        qm(l,i,j,k,iv  ,3) = v      +half*dvz      +sv0      *dtdz*half
        qm(l,i,j,k,iw  ,3) = w      +half*dwz      +sw0      *dtdz*half
        
     end do
  end do
  end do
  end do

end subroutine trace3d
#endif
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine cmpgdnv(fm,gm,qm,im1,im2,jm1,jm2,km1,km2, &
     &             fp,gp,qp,ip1,ip2,jp1,jp2,kp1,kp2, c, &
     &              flx,tmp,ilo,ihi,jlo,jhi,klo,khi, & 
     &                      ln,lt1,lt2,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  integer ::ngrid
  integer ::ln,lt1,lt2
  integer ::im1,im2,jm1,jm2,km1,km2
  integer ::ip1,ip2,jp1,jp2,kp1,kp2
  integer ::ilo,ihi,jlo,jhi,klo,khi
  real(dp),dimension(1:nvector,im1:im2,jm1:jm2,km1:km2,1:npri,1:ndim)::qm
  real(dp),dimension(1:nvector,im1:im2,jm1:jm2,km1:km2,1:nmat,1:ndim)::fm
  real(dp),dimension(1:nvector,im1:im2,jm1:jm2,km1:km2,1:nmat,1:ndim)::gm
  real(dp),dimension(1:nvector,ip1:ip2,jp1:jp2,kp1:kp2,1:npri,1:ndim)::qp
  real(dp),dimension(1:nvector,ip1:ip2,jp1:jp2,kp1:kp2,1:nmat,1:ndim)::fp
  real(dp),dimension(1:nvector,ip1:ip2,jp1:jp2,kp1:kp2,1:nmat,1:ndim)::gp
  real(dp),dimension(1:nvector,ip1:ip2,jp1:jp2,kp1:kp2,1:nvar)::flx
  real(dp),dimension(1:nvector,ip1:ip2,jp1:jp2,kp1:kp2,1:2)::tmp
  real(dp),dimension(1:nvector,ip1:ip2,jp1:jp2,kp1:kp2)::c

  ! local variables
  integer ::i, j, k, n, l, idim, jdim, imat
  real(dp),dimension(1:nvector,1:npri),save::qleft,qright,qgdnv
  real(dp),dimension(1:nvector,1:nmat),save::fleft,fright,fgdnv
  real(dp),dimension(1:nvector,1:nmat),save::gleft,gright,ggdnv
  real(dp),dimension(1:nvector,1:nmat),save::kappa_matgdnv
  real(dp),dimension(1:nvector),save::etot,ekin,cleft,cright,egdnv,cgdnv,kappa_hatgdnv
  logical ,dimension(1:nvector),save::wall,body

  idim= ln -1

  do k = klo, khi
  do j = jlo, jhi
  do i = ilo, ihi
           
     ! Total density
     do l = 1, ngrid
        qleft (l,1) = qm(l,i,j,k,1,idim)
        qright(l,1) = qp(l,i,j,k,1,idim)
     end do
     
     ! Normal velocity
     do l = 1, ngrid
        qleft (l,2) = qm(l,i,j,k,ln,idim)
        qright(l,2) = qp(l,i,j,k,ln,idim)
     end do
     
     ! Pressure
     do l = 1, ngrid
        qleft (l,npri) = qm(l,i,j,k,npri,idim)
        qright(l,npri) = qp(l,i,j,k,npri,idim)
     end do
#if NDIM>1
     ! Tangential velocity 1
     do l = 1, ngrid
        qleft (l,3) = qm(l,i,j,k,lt1,idim)
        qright(l,3) = qp(l,i,j,k,lt1,idim)
     end do
#endif
#if NDIM>2
     ! Tangential velocity 2
     do l = 1, ngrid
        qleft (l,4) = qm(l,i,j,k,lt2,idim)
        qright(l,4) = qp(l,i,j,k,lt2,idim)
     end do
#endif           
     ! Mass and volume fraction
     do imat = 1,nmat
        do l = 1, ngrid
           fleft (l,imat) = fm(l,i,j,k,imat,idim)
           fright(l,imat) = fp(l,i,j,k,imat,idim)
           gleft (l,imat) = gm(l,i,j,k,imat,idim)
           gright(l,imat) = gp(l,i,j,k,imat,idim)
        end do
     end do
     
     ! Sound speed
     if (ln==2)then
        do l = 1,ngrid
           cleft (l) = c(l,i-1,j,k)
           cright(l) = c(l,i  ,j,k)
        end do
     else if(ln==3) then
        do l = 1,ngrid
           cleft (l) = c(l,i,j-1,k)
           cright(l) = c(l,i,j  ,k)
        end do
     else
        do l = 1,ngrid
           cleft (l) = c(l,i,j,k-1)
           cright(l) = c(l,i,j,k  )
        end do
     end if
     
     if(static)then
        ! First material is embedded body
        do l = 1, ngrid
           body(l) = fright(l,1) > 0.01 .or. fleft(l,1) > 0.01
        end do
        do l = 1,ngrid
           if(body(l))then
              if(fright(l,1) > 0.01)then
                 fright(l,1:nmat)=fleft(l,1:nmat)
                 gright(l,1:nmat)=gleft(l,1:nmat)
                 qright(l,1:npri)=qleft(l,1:npri)
                 qright(l,2)=-qleft(l,2) ! Reflect
                 cright(l)=cleft(l)
              endif
              if(fleft(l,1) > 0.01)then
                 fleft(l,1:nmat)=fright(l,1:nmat)
                 gleft(l,1:nmat)=gright(l,1:nmat)
                 qleft(l,1:npri)=qright(l,1:npri)
                 qleft(l,2)=-qright(l,2) ! Reflect
                 cleft(l)=cright(l)
              endif
           endif
        end do
     end if

     ! Solve Riemann problem
     call riemann_acoustic(fleft,fright,&
          &                gleft,gright,&
          &                qleft,qright,&
          &                cleft,cright,&
          &                fgdnv,ggdnv,qgdnv, ngrid)
     
     ! Compute fluxes
     
     ! Mass density
     do l = 1, ngrid 
        flx(l,i,j,k,1) = qgdnv(l,1)*qgdnv(l,2)
     end do
     
     ! Normal momentum
     ekin(1:ngrid)=0.0
     if(geom>1.and.idim==1)then
        do l = 1,ngrid
           flx(l,i,j,k,ln) = flx(l,i,j,k,1)*qgdnv(l,2)
        end do
     else
        do l = 1,ngrid
           flx(l,i,j,k,ln) = flx(l,i,j,k,1)*qgdnv(l,2)+qgdnv(l,npri)
        end do
     endif
     ! P for -grad(P)
     do l=1,ngrid
        tmp(l,i,j,k,2)=qgdnv(l,npri)
     end do
#if NDIM>1
     ! Transverse momentum 1
     do l = 1, ngrid
        flx(l,i,j,k,lt1) = flx(l,i,j,k,1)*qgdnv(l,3)
     end do
#endif
#if NDIM>2
     ! Transverse momentum 2
     do l = 1, ngrid
        flx(l,i,j,k,lt2) = flx(l,i,j,k,1)*qgdnv(l,4)
     end do
#endif           
     ! Call inverse eos routine
     call eosinv(fgdnv,ggdnv,qgdnv,egdnv,cgdnv,kappa_matgdnv,kappa_hatgdnv,ngrid)
     
     ! Total energy
     do l = 1, ngrid
        etot(l)=egdnv(l)
     end do
     do jdim = 1,ndim
        do l = 1, ngrid
           etot(l)=etot(l)+half*qgdnv(l,1)*qgdnv(l,jdim+1)**2
        end do
     end do
     do l = 1, ngrid
        flx(l,i,j,k,npri) = qgdnv(l,2)*(etot(l)+qgdnv(l,npri))
     end do
     
     ! Volume fraction
     do imat = 1,nmat
        do l = 1,ngrid
           flx(l,i,j,k,imat+npri) = fgdnv(l,imat)*qgdnv(l,2)
        end do
     end do
     
     ! Fluid density
     do imat = 1,nmat
        do l = 1,ngrid
           flx(l,i,j,k,imat+npri+nmat) = ggdnv(l,imat)*qgdnv(l,2)
        end do
     end do
     
     ! u for div(u)
     do l=1,ngrid
        tmp(l,i,j,k,1)=qgdnv(l,2)
     end do
     
  end do
  end do
  end do
  
end subroutine cmpgdnv
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine qslope(q,dq,dx,dt,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  integer::ngrid
  real(dp)::dx,dt
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri)::q 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::dq

  ! local arrays
  integer::i, j, k, l, n
  real(dp)::dsgn, dlim, dcen, dlft, drgt, slop
  real(dp)::dfll,dflm,dflr,dfml,dfmm,dfmr,dfrl,dfrm,dfrr
  real(dp)::dflll,dflml,dflrl,dfmll,dfmml,dfmrl,dfrll,dfrml,dfrrl
  real(dp)::dfllm,dflmm,dflrm,dfmlm,dfmmm,dfmrm,dfrlm,dfrmm,dfrrm
  real(dp)::dfllr,dflmr,dflrr,dfmlr,dfmmr,dfmrr,dfrlr,dfrmr,dfrrr
  real(dp)::vmin,vmax,dfx,dfy,dfz,dff
  integer::ilo,ihi,jlo,jhi,klo,khi
  
  ilo=MIN(1,iu1+1); ihi=MAX(1,iu2-1)
  jlo=MIN(1,ju1+1); jhi=MAX(1,ju2-1)
  klo=MIN(1,ku1+1); khi=MAX(1,ku2-1)

  if(slope_type==0)then
     dq=zero
     return
  end if

#if NDIM==1
  do k = klo, khi
  do j = jlo, jhi
  do i = ilo, ihi
     do n = 1, npri
        if(slope_type==1.or.slope_type==2)then  ! minmod or average
           do l = 1, ngrid
              dlft = slope_type*(q(l,i  ,j,k,n) - q(l,i-1,j,k,n))
              drgt = slope_type*(q(l,i+1,j,k,n) - q(l,i  ,j,k,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one, dcen)
              slop = min(abs(dlft),abs(drgt))
              dlim = slop
              if((dlft*drgt)<=zero)dlim=zero
              dq(l,i,j,k,n,1) = dsgn*min(dlim,abs(dcen))
           end do
        else if(slope_type==3)then ! superbee
           do l = 1, ngrid
              dcen = q(l,i,j,k,2)*dt/dx
              dlft = two/(one+dcen)*(q(l,i,j,k,n)-q(l,i-1,j,k,n))
              drgt = two/(one-dcen)*(q(l,i+1,j,k,n)-q(l,i,j,k,n))
              dsgn = sign(one, dlft)
              slop = min(abs(dlft),abs(drgt))
              dlim = slop
              if((dlft*drgt)<=zero)dlim=zero
              dq(l,i,j,k,n,1) = dsgn*dlim
           end do
        else if(slope_type==4)then ! ultrabee
           do l = 1, ngrid
              dcen = q(l,i,j,k,2)*dt/dx
              if(dcen>=0)then
                 dlft = two/(zero+dcen+1d-10)*(q(l,i,j,k,n)-q(l,i-1,j,k,n))
                 drgt = two/(one -dcen      )*(q(l,i+1,j,k,n)-q(l,i,j,k,n))
              else
                 dlft = two/(one +dcen      )*(q(l,i,j,k,n)-q(l,i-1,j,k,n))
                 drgt = two/(zero-dcen+1d-10)*(q(l,i+1,j,k,n)-q(l,i,j,k,n))
              endif
              dsgn = sign(one, dlft)
              slop = min(abs(dlft),abs(drgt))
              dlim = slop
              if((dlft*drgt)<=zero)dlim=zero
              dq(l,i,j,k,n,1) = dsgn*dlim
           end do
        else
           write(*,*)'Unknown slope type'
           stop
        end if
     end do
  end do
  end do
  end do
#endif

#if NDIM==2              
  do k = klo, khi
  do j = jlo, jhi
  do i = ilo, ihi
     if(slope_type==1.or.slope_type==2)then  ! minmod or average
        do n = 1, npri
           ! slopes in first coordinate direction
           do l = 1, ngrid
              dlft = slope_type*(q(l,i  ,j,k,n) - q(l,i-1,j,k,n))
              drgt = slope_type*(q(l,i+1,j,k,n) - q(l,i  ,j,k,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one, dcen)
              slop = min(abs(dlft),abs(drgt))
              dlim = slop
              if((dlft*drgt)<=zero)dlim=zero
              dq(l,i,j,k,n,1) = dsgn*min(dlim,abs(dcen))
           end do
           ! slopes in second coordinate direction
           do l = 1, ngrid
              dlft = slope_type*(q(l,i,j  ,k,n) - q(l,i,j-1,k,n))
              drgt = slope_type*(q(l,i,j+1,k,n) - q(l,i,j  ,k,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one,dcen)
              slop = min(abs(dlft),abs(drgt))
              dlim = slop
              if((dlft*drgt)<=zero)dlim=zero
              dq(l,i,j,k,n,2) = dsgn*min(dlim,abs(dcen))
           end do
        end do
     else if(slope_type==3)then ! positivity preserving 2d unsplit slope
        do n = 1, npri
           do l = 1, ngrid
              dfll = q(l,i-1,j-1,k,n)-q(l,i,j,k,n)
              dflm = q(l,i-1,j  ,k,n)-q(l,i,j,k,n)
              dflr = q(l,i-1,j+1,k,n)-q(l,i,j,k,n)
              dfml = q(l,i  ,j-1,k,n)-q(l,i,j,k,n)
              dfmm = q(l,i  ,j  ,k,n)-q(l,i,j,k,n)
              dfmr = q(l,i  ,j+1,k,n)-q(l,i,j,k,n)
              dfrl = q(l,i+1,j-1,k,n)-q(l,i,j,k,n)
              dfrm = q(l,i+1,j  ,k,n)-q(l,i,j,k,n)
              dfrr = q(l,i+1,j+1,k,n)-q(l,i,j,k,n)
              vmin = min(dfll,dflm,dflr,dfml,dfmm,dfmr,dfrl,dfrm,dfrr)
              vmax = max(dfll,dflm,dflr,dfml,dfmm,dfmr,dfrl,dfrm,dfrr)
              dfx  = half*(q(l,i+1,j,k,n)-q(l,i-1,j,k,n))
              dfy  = half*(q(l,i,j+1,k,n)-q(l,i,j-1,k,n))
              dff  = half*(abs(dfx)+abs(dfy))
              if(dff>zero)then
                 slop = min(one,min(abs(vmin),abs(vmax))/dff)
              else
                 slop = one
              endif
              dlim = slop
              dq(l,i,j,k,n,1) = dlim*dfx
              dq(l,i,j,k,n,2) = dlim*dfy
           end do
        end do
     else
        write(*,*)'Unknown slope type'
        stop
     endif
  end do
  end do
  end do
#endif

#if NDIM==3
  do k = klo, khi
  do j = jlo, jhi
  do i = ilo, ihi
     if(slope_type==1.or.slope_type==2)then  ! minmod or average
        do n = 1, npri
           ! slopes in first coordinate direction
           do l = 1, ngrid
              dlft = slope_type*(q(l,i  ,j,k,n) - q(l,i-1,j,k,n))
              drgt = slope_type*(q(l,i+1,j,k,n) - q(l,i  ,j,k,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one, dcen)
              slop = min(abs(dlft),abs(drgt))
              dlim = slop
              if((dlft*drgt)<=zero)dlim=zero
              dq(l,i,j,k,n,1) = dsgn*min(dlim,abs(dcen))
           end do
           ! slopes in second coordinate direction
           do l = 1, ngrid
              dlft = slope_type*(q(l,i,j  ,k,n) - q(l,i,j-1,k,n))
              drgt = slope_type*(q(l,i,j+1,k,n) - q(l,i,j  ,k,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one,dcen)
              slop = min(abs(dlft),abs(drgt))
              dlim = slop
              if((dlft*drgt)<=zero)dlim=zero
              dq(l,i,j,k,n,2) = dsgn*min(dlim,abs(dcen))
           end do
           ! slopes in third coordinate direction
           do l = 1, ngrid
              dlft = slope_type*(q(l,i,j,k  ,n) - q(l,i,j,k-1,n))
              drgt = slope_type*(q(l,i,j,k+1,n) - q(l,i,j,k  ,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one,dcen)
              slop = min(abs(dlft),abs(drgt))
              dlim = slop
              if((dlft*drgt)<=zero)dlim=zero
              dq(l,i,j,k,n,3) = dsgn*min(dlim,abs(dcen))
           end do
        end do
     else if(slope_type==3)then ! positivity preserving 3d unsplit slope
        do n = 1, npri
           do l = 1, ngrid
              dflll = q(l,i-1,j-1,k-1,n)-q(l,i,j,k,n)
              dflml = q(l,i-1,j  ,k-1,n)-q(l,i,j,k,n)
              dflrl = q(l,i-1,j+1,k-1,n)-q(l,i,j,k,n)
              dfmll = q(l,i  ,j-1,k-1,n)-q(l,i,j,k,n)
              dfmml = q(l,i  ,j  ,k-1,n)-q(l,i,j,k,n)
              dfmrl = q(l,i  ,j+1,k-1,n)-q(l,i,j,k,n)
              dfrll = q(l,i+1,j-1,k-1,n)-q(l,i,j,k,n)
              dfrml = q(l,i+1,j  ,k-1,n)-q(l,i,j,k,n)
              dfrrl = q(l,i+1,j+1,k-1,n)-q(l,i,j,k,n)
              dfllm = q(l,i-1,j-1,k  ,n)-q(l,i,j,k,n)
              dflmm = q(l,i-1,j  ,k  ,n)-q(l,i,j,k,n)
              dflrm = q(l,i-1,j+1,k  ,n)-q(l,i,j,k,n)
              dfmlm = q(l,i  ,j-1,k  ,n)-q(l,i,j,k,n)
              dfmmm = q(l,i  ,j  ,k  ,n)-q(l,i,j,k,n)
              dfmrm = q(l,i  ,j+1,k  ,n)-q(l,i,j,k,n)
              dfrlm = q(l,i+1,j-1,k  ,n)-q(l,i,j,k,n)
              dfrmm = q(l,i+1,j  ,k  ,n)-q(l,i,j,k,n)
              dfrrm = q(l,i+1,j+1,k  ,n)-q(l,i,j,k,n)
              dfllr = q(l,i-1,j-1,k+1,n)-q(l,i,j,k,n)
              dflmr = q(l,i-1,j  ,k+1,n)-q(l,i,j,k,n)
              dflrr = q(l,i-1,j+1,k+1,n)-q(l,i,j,k,n)
              dfmlr = q(l,i  ,j-1,k+1,n)-q(l,i,j,k,n)
              dfmmr = q(l,i  ,j  ,k+1,n)-q(l,i,j,k,n)
              dfmrr = q(l,i  ,j+1,k+1,n)-q(l,i,j,k,n)
              dfrlr = q(l,i+1,j-1,k+1,n)-q(l,i,j,k,n)
              dfrmr = q(l,i+1,j  ,k+1,n)-q(l,i,j,k,n)
              dfrrr = q(l,i+1,j+1,k+1,n)-q(l,i,j,k,n)
              vmin = min(dflll,dflml,dflrl,dfmll,dfmml,dfmrl,dfrll,dfrml,dfrrl, &
                   &     dfllm,dflmm,dflrm,dfmlm,dfmmm,dfmrm,dfrlm,dfrmm,dfrrm, &
                   &     dfllr,dflmr,dflrr,dfmlr,dfmmr,dfmrr,dfrlr,dfrmr,dfrrr)
              vmax = max(dflll,dflml,dflrl,dfmll,dfmml,dfmrl,dfrll,dfrml,dfrrl, &
                   &     dfllm,dflmm,dflrm,dfmlm,dfmmm,dfmrm,dfrlm,dfrmm,dfrrm, &
                   &     dfllr,dflmr,dflrr,dfmlr,dfmmr,dfmrr,dfrlr,dfrmr,dfrrr)
              dfx  = half*(q(l,i+1,j,k,n)-q(l,i-1,j,k,n))
              dfy  = half*(q(l,i,j+1,k,n)-q(l,i,j-1,k,n))
              dfz  = half*(q(l,i,j,k+1,n)-q(l,i,j,k-1,n))
              dff  = half*(abs(dfx)+abs(dfy)+abs(dfz))
              if(dff>zero)then
                 slop = min(one,min(abs(vmin),abs(vmax))/dff)
              else
                 slop = one
              endif
              dlim = slop
              dq(l,i,j,k,n,1) = dlim*dfx
              dq(l,i,j,k,n,2) = dlim*dfy
              dq(l,i,j,k,n,3) = dlim*dfz
           end do
        end do
     else
        write(*,*)'Unknown slope type'
        stop
     endif
  end do
  end do
  end do
#endif
  
end subroutine qslope
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine fslope(f,df,q,dx,dt,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  integer::ngrid
  real(dp)::dx,dt
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri)::q 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat)::f 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::df

  ! local arrays
  integer::i, j, k, l, n
  real(dp)::dsgn, dcen, dlft, drgt, slop
  real(dp)::dfll,dflm,dflr,dfml,dfmm,dfmr,dfrl,dfrm,dfrr
  real(dp)::dflll,dflml,dflrl,dfmll,dfmml,dfmrl,dfrll,dfrml,dfrrl
  real(dp)::dfllm,dflmm,dflrm,dfmlm,dfmmm,dfmrm,dfrlm,dfrmm,dfrrm
  real(dp)::dfllr,dflmr,dflrr,dfmlr,dfmmr,dfmrr,dfrlr,dfrmr,dfrrr
  real(dp)::vmin,vmax,dfx,dfy,dfz,dff
  integer::ilo,ihi,jlo,jhi,klo,khi
  real(dp),dimension(1:nvector),save::dlim
  
  ilo=MIN(1,iu1+1); ihi=MAX(1,iu2-1)
  jlo=MIN(1,ju1+1); jhi=MAX(1,ju2-1)
  klo=MIN(1,ku1+1); khi=MAX(1,ku2-1)

  if(slope_type==0)then
     df=zero
     return
  end if

#if NDIM==1
  do k = klo, khi
  do j = jlo, jhi
  do i = ilo, ihi
     if(slope_type==1.or.slope_type==2)then  ! minmod or average
        do n = 1, nmat
           do l = 1, ngrid
              dlim(l)=one
           end do
        end do
        do n = 1, nmat
           do l = 1, ngrid
              dlft = slope_type*(f(l,i,j,k,n)-f(l,i-1,j,k,n))
              drgt = slope_type*(f(l,i+1,j,k,n)-f(l,i,j,k,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one, dcen)
              slop = min(abs(dlft),abs(drgt))
              if((dlft*drgt)<=zero)then
                 slop = zero
              else
                 slop = min(slop/abs(dcen),one)
              endif
              dlim(l) = min(slop,dlim(l))
           end do
        end do
        do n = 1, nmat
           do l = 1, ngrid
              df(l,i,j,k,n,1) = dlim(l)*half*(f(l,i+1,j,k,n)-f(l,i-1,j,k,n))
           end do
        end do
     else if(slope_type==3)then ! superbee
        do n = 1, nmat
           do l = 1, ngrid
              dcen = q(l,i,j,k,2)*dt/dx
              dlft = two/(one+dcen)*(f(l,i,j,k,n)-f(l,i-1,j,k,n))
              drgt = two/(one-dcen)*(f(l,i+1,j,k,n)-f(l,i,j,k,n))
              dsgn = sign(one, dlft)
              slop = min(abs(dlft),abs(drgt))
              dlim(l) = slop
              if((dlft*drgt)<=zero)dlim(l)=zero
              df(l,i,j,k,n,1) = dsgn*dlim(l)
           end do
        end do
     else if(slope_type==4)then ! ultrabee
        do n = 1, nmat
           do l = 1, ngrid
              dcen = q(l,i,j,k,2)*dt/dx
              if(dcen>=0)then
                 dlft = two/(zero+dcen+1d-10)*(f(l,i,j,k,n)-f(l,i-1,j,k,n))
                 drgt = two/(one -dcen      )*(f(l,i+1,j,k,n)-f(l,i,j,k,n))
              else
                 dlft = two/(one +dcen      )*(f(l,i,j,k,n)-f(l,i-1,j,k,n))
                 drgt = two/(zero-dcen+1d-10)*(f(l,i+1,j,k,n)-f(l,i,j,k,n))
              endif
              dsgn = sign(one, dlft)
              slop = min(abs(dlft),abs(drgt))
              dlim(l) = slop
              if((dlft*drgt)<=zero)dlim(l)=zero
              df(l,i,j,k,n,1) = dsgn*dlim(l)
           end do
        end do
     else
        write(*,*)'Unknown slope type'
        stop
     end if
  end do
  end do
  end do
#endif

#if NDIM==2
  do k = klo, khi
  do j = jlo, jhi
  do i = ilo, ihi
     if(slope_type==1.or.slope_type==2)then  ! minmod or average
        ! slopes in first coordinate direction
        do l = 1, ngrid
           dlim(l)=one
        enddo
        do n = 1, nmat
           do l = 1, ngrid
              dlft = slope_type*(f(l,i,j,k,n)-f(l,i-1,j,k,n))
              drgt = slope_type*(f(l,i+1,j,k,n)-f(l,i,j,k,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one, dcen)
              slop = min(abs(dlft),abs(drgt))
              if((dlft*drgt)<=zero)then
                 slop=zero
              else
                 slop=min(slop/abs(dcen),one)
              endif
              dlim(l)=min(slop,dlim(l))
           end do
        end do
        do n = 1, nmat
           do l = 1, ngrid
              df(l,i,j,k,n,1) = dlim(l)*half*(f(l,i+1,j,k,n)-f(l,i-1,j,k,n))
           end do
        end do
        ! slopes in second coordinate direction
        do l = 1, ngrid
           dlim(l)=one
        enddo
        do n = 1, nmat
           do l = 1, ngrid
              dlft = slope_type*(f(l,i,j,k,n)-f(l,i,j-1,k,n))
              drgt = slope_type*(f(l,i,j+1,k,n)-f(l,i,j,k,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one, dcen)
              slop = min(abs(dlft),abs(drgt))
              if((dlft*drgt)<=zero)then
                 slop=zero
              else
                 slop=min(slop/abs(dcen),one)
              endif
              dlim(l)=min(slop,dlim(l))
           end do
        end do
        do n = 1, nmat
           do l = 1, ngrid
              df(l,i,j,k,n,2) = dlim(l)*half*(f(l,i,j+1,k,n)-f(l,i,j-1,k,n))
           end do
        end do
     else if(slope_type==3)then ! positivity preserving 2d unsplit slope
        do l = 1, ngrid
           dlim(l) = one
        enddo
        do n = 1, nmat
           do l = 1, ngrid
              dfll = f(l,i-1,j-1,k,n)-f(l,i,j,k,n)
              dflm = f(l,i-1,j  ,k,n)-f(l,i,j,k,n)
              dflr = f(l,i-1,j+1,k,n)-f(l,i,j,k,n)
              dfml = f(l,i  ,j-1,k,n)-f(l,i,j,k,n)
              dfmm = f(l,i  ,j  ,k,n)-f(l,i,j,k,n)
              dfmr = f(l,i  ,j+1,k,n)-f(l,i,j,k,n)
              dfrl = f(l,i+1,j-1,k,n)-f(l,i,j,k,n)
              dfrm = f(l,i+1,j  ,k,n)-f(l,i,j,k,n)
              dfrr = f(l,i+1,j+1,k,n)-f(l,i,j,k,n)                    
              vmin = min(dfll,dflm,dflr,dfml,dfmm,dfmr,dfrl,dfrm,dfrr)
              vmax = max(dfll,dflm,dflr,dfml,dfmm,dfmr,dfrl,dfrm,dfrr)
              dfx  = half*(f(l,i+1,j,k,n)-f(l,i-1,j,k,n))
              dfy  = half*(f(l,i,j+1,k,n)-f(l,i,j-1,k,n))
              dff  = half*(abs(dfx)+abs(dfy))
              if(dff>zero)then
                 slop = min(one,min(abs(vmin),abs(vmax))/dff)
              else
                 slop = one
              endif
              dlim(l) = min(slop,dlim(l))
           end do
        end do
        ! Computed 2nd order limited slopes
        do n = 1, nmat
           do l = 1, ngrid
              df(l,i,j,k,n,1) = dlim(l)*half*(f(l,i+1,j,k,n)-f(l,i-1,j,k,n))
              df(l,i,j,k,n,2) = dlim(l)*half*(f(l,i,j+1,k,n)-f(l,i,j-1,k,n))
           end do
        end do
     else
        write(*,*)'Unkown slope type'
        stop
     endif
  end do
  end do
  end do
#endif

#if NDIM==3
  do k = klo, khi
  do j = jlo, jhi
  do i = ilo, ihi
     if(slope_type==1.or.slope_type==2)then  ! minmod or average
        ! slopes in first coordinate direction
        do l = 1, ngrid
           dlim(l)=one
        enddo
        do n = 1, nmat
           do l = 1, ngrid
              dlft = slope_type*(f(l,i,j,k,n)-f(l,i-1,j,k,n))
              drgt = slope_type*(f(l,i+1,j,k,n)-f(l,i,j,k,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one, dcen)
              slop = min(abs(dlft),abs(drgt))
              if((dlft*drgt)<=zero)then
                 slop=zero
              else
                 slop=min(slop/abs(dcen),one)
              endif
              dlim(l)=min(slop,dlim(l))
           end do
        end do
        do n = 1, nmat
           do l = 1, ngrid
              df(l,i,j,k,n,1) = dlim(l)*half*(f(l,i+1,j,k,n)-f(l,i-1,j,k,n))
           end do
        end do
        ! slopes in second coordinate direction
        do l = 1, ngrid
           dlim(l)=one
        enddo
        do n = 1, nmat
           do l = 1, ngrid
              dlft = slope_type*(f(l,i,j,k,n)-f(l,i,j-1,k,n))
              drgt = slope_type*(f(l,i,j+1,k,n)-f(l,i,j,k,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one, dcen)
              slop = min(abs(dlft),abs(drgt))
              if((dlft*drgt)<=zero)then
                 slop=zero
              else
                 slop=min(slop/abs(dcen),one)
              endif
              dlim(l)=min(slop,dlim(l))
           end do
        end do
        do n = 1, nmat
           do l = 1, ngrid
              df(l,i,j,k,n,2) = dlim(l)*half*(f(l,i,j+1,k,n)-f(l,i,j-1,k,n))
           end do
        end do
        ! slopes in third coordinate direction
        do l = 1, ngrid
           dlim(l)=one
        enddo
        do n = 1, nmat
           do l = 1, ngrid
              dlft = slope_type*(f(l,i,j,k,n)-f(l,i,j,k-1,n))
              drgt = slope_type*(f(l,i,j,k+1,n)-f(l,i,j,k,n))
              dcen = half*(dlft+drgt)/slope_type
              dsgn = sign(one, dcen)
              slop = min(abs(dlft),abs(drgt))
              if((dlft*drgt)<=zero)then
                 slop=zero
              else
                 slop=min(slop/abs(dcen),one)
              endif
              dlim(l)=min(slop,dlim(l))
           end do
        end do
        do n = 1, nmat
           do l = 1, ngrid
              df(l,i,j,k,n,3) = dlim(l)*half*(f(l,i,j,k+1,n)-f(l,i,j,k-1,n))
           end do
        end do
     else if(slope_type==3)then ! positivity preserving 3d unsplit slope
        do l = 1, ngrid
           dlim(l)=one
        enddo
        do n = 1, nmat
           do l = 1, ngrid
              dflll = f(l,i-1,j-1,k-1,n)-f(l,i,j,k,n)
              dflml = f(l,i-1,j  ,k-1,n)-f(l,i,j,k,n)
              dflrl = f(l,i-1,j+1,k-1,n)-f(l,i,j,k,n)
              dfmll = f(l,i  ,j-1,k-1,n)-f(l,i,j,k,n)
              dfmml = f(l,i  ,j  ,k-1,n)-f(l,i,j,k,n)
              dfmrl = f(l,i  ,j+1,k-1,n)-f(l,i,j,k,n)
              dfrll = f(l,i+1,j-1,k-1,n)-f(l,i,j,k,n)
              dfrml = f(l,i+1,j  ,k-1,n)-f(l,i,j,k,n)
              dfrrl = f(l,i+1,j+1,k-1,n)-f(l,i,j,k,n)
              dfllm = f(l,i-1,j-1,k  ,n)-f(l,i,j,k,n)
              dflmm = f(l,i-1,j  ,k  ,n)-f(l,i,j,k,n)
              dflrm = f(l,i-1,j+1,k  ,n)-f(l,i,j,k,n)
              dfmlm = f(l,i  ,j-1,k  ,n)-f(l,i,j,k,n)
              dfmmm = f(l,i  ,j  ,k  ,n)-f(l,i,j,k,n)
              dfmrm = f(l,i  ,j+1,k  ,n)-f(l,i,j,k,n)
              dfrlm = f(l,i+1,j-1,k  ,n)-f(l,i,j,k,n)
              dfrmm = f(l,i+1,j  ,k  ,n)-f(l,i,j,k,n)
              dfrrm = f(l,i+1,j+1,k  ,n)-f(l,i,j,k,n)
              dfllr = f(l,i-1,j-1,k+1,n)-f(l,i,j,k,n)
              dflmr = f(l,i-1,j  ,k+1,n)-f(l,i,j,k,n)
              dflrr = f(l,i-1,j+1,k+1,n)-f(l,i,j,k,n)
              dfmlr = f(l,i  ,j-1,k+1,n)-f(l,i,j,k,n)
              dfmmr = f(l,i  ,j  ,k+1,n)-f(l,i,j,k,n)
              dfmrr = f(l,i  ,j+1,k+1,n)-f(l,i,j,k,n)
              dfrlr = f(l,i+1,j-1,k+1,n)-f(l,i,j,k,n)
              dfrmr = f(l,i+1,j  ,k+1,n)-f(l,i,j,k,n)
              dfrrr = f(l,i+1,j+1,k+1,n)-f(l,i,j,k,n)
              vmin = min(dflll,dflml,dflrl,dfmll,dfmml,dfmrl,dfrll,dfrml,dfrrl, &
                   &     dfllm,dflmm,dflrm,dfmlm,dfmmm,dfmrm,dfrlm,dfrmm,dfrrm, &
                   &     dfllr,dflmr,dflrr,dfmlr,dfmmr,dfmrr,dfrlr,dfrmr,dfrrr)
              vmax = max(dflll,dflml,dflrl,dfmll,dfmml,dfmrl,dfrll,dfrml,dfrrl, &
                   &     dfllm,dflmm,dflrm,dfmlm,dfmmm,dfmrm,dfrlm,dfrmm,dfrrm, &
                   &     dfllr,dflmr,dflrr,dfmlr,dfmmr,dfmrr,dfrlr,dfrmr,dfrrr)
              dfx  = half*(f(l,i+1,j,k,n)-f(l,i-1,j,k,n))
              dfy  = half*(f(l,i,j+1,k,n)-f(l,i,j-1,k,n))
              dfz  = half*(f(l,i,j,k+1,n)-f(l,i,j,k-1,n))
              dff  = half*(abs(dfx)+abs(dfy)+abs(dfz))
              if(dff>zero)then
                 slop = min(one,min(abs(vmin),abs(vmax))/dff)
              else
                 slop = one
              endif
              dlim(l) = min(slop,dlim(l))
           end do
        end do
        do n = 1, nmat
           do l = 1, ngrid
              df(l,i,j,k,n,1) = dlim(l)*half*(f(l,i+1,j,k,n)-f(l,i-1,j,k,n))
              df(l,i,j,k,n,2) = dlim(l)*half*(f(l,i,j+1,k,n)-f(l,i,j-1,k,n))
              df(l,i,j,k,n,3) = dlim(l)*half*(f(l,i,j,k+1,n)-f(l,i,j,k-1,n))
           end do
        end do
     else
        write(*,*)'Unkown slope type'
        stop
     endif
  end do
  end do
  end do
#endif
  
end subroutine fslope
!###########################################################
!###########################################################
!###########################################################
!###########################################################
../patch/multimat/uplmde.f90
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine tracex(qin,fin,gamma_c,dq,df,qm,qp,fm,fp,dx,dt,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  integer::ngrid
  real(dp)::dx, dt  

  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::dq 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::qm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri,1:ndim)::qp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:npri)::qin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::df
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::fm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat,1:ndim)::fp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat)::fin
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nmat)::gamma_c

  ! Local variables
  integer ::ilo,ihi,jlo,jhi,klo,khi
  integer ::i, j, k, l, n, imat
  integer ::if, ir, ie, iu, ip
  real(dp)::dtdx,project_out,gamh,rtot
  real(dp)::u, p, cc, pp, ccc
  real(dp)::dux, dpx,ep,rr
  real(dp),dimension(1:nmat)::f,r,e,gamc,dfx,drx,dex,alpha0r,alpha0e,alpha0f
  real(dp),dimension(1:nmat)::azrright,azeright,azfright,azrleft,azeleft,azfleft
  real(dp)::alpham, alphap, spminus, spplus, spzero
  real(dp)::apright, amright, apleft,  amleft
  
  dtdx = dt/dx
  ilo=MIN(1,iu1+1); ihi=MAX(1,iu2-1)
  jlo=MIN(1,ju1+1); jhi=MAX(1,ju2-1)
  klo=MIN(1,ku1+1); khi=MAX(1,ku2-1)
  iu=2*nmat+1; ip=npri
  project_out=one !zero

  do k = klo, khi
     do j = jlo, jhi
        do i = ilo, ihi
           do l = 1, ngrid

              ! Fixed values
              gamh = zero
              do imat = 1,nmat
                 f(imat) = fin(l,i,j,k,imat)
                 gamc(imat) = gamma_c(l,i,j,k,imat)
                 gamh = gamh + f(imat)/gamc(imat)
              end do
              gamh = one/gamh

              ! Cell centered values
              rtot = 0.0
              do imat = 1,nmat
                 ir=imat; ie=imat+nmat
                 r(imat) = qin(l,i,j,k,ir)
                 e(imat) = qin(l,i,j,k,ie)
                 rtot = rtot + f(imat)*r(imat)
              end do
              u = qin(l,i,j,k,iu)
              p = qin(l,i,j,k,ip)

              ! TVD slopes in X direction
              do imat = 1,nmat
                 ir=imat; ie=imat+nmat
                 dfx(imat) = df(l,i,j,k,ir,1)
                 drx(imat) = dq(l,i,j,k,ir,1)
                 dex(imat) = dq(l,i,j,k,ie,1)
              end do
              dux = dq(l,i,j,k,iu,1)
              dpx = dq(l,i,j,k,ip,1)
              
              ! Sound speed
              pp  = gamh*p
              cc  = sqrt(pp/rtot)
              
              ! Supersonic fix for high-velocity gradients
              ccc = cc
!!               if(ABS(dux) > three*cc)ccc=zero

              ! Characteristic analysis along X direction
              alpham  = half*(dpx/pp - dux/cc)
              alphap  = half*(dpx/pp + dux/cc)
              do imat = 1,nmat
                 alpha0f(imat) = dfx(imat)
                 alpha0r(imat) = drx(imat) - dpx*(r(imat)  )/gamc(imat)/p
                 alpha0e(imat) = dex(imat) - dpx*(e(imat)+p)/gamc(imat)/p
              end do

              ! Right state
              spminus = (u-ccc)*dtdx
              spplus  = (u+ccc)*dtdx
              spzero  = (u    )*dtdx
              if((u+ccc)>zero)spplus =-project_out
              if((u-ccc)>zero)spminus=-project_out
              if( u     >zero)spzero =-project_out

              apright = half*(-one-spplus )*alphap
              amright = half*(-one-spminus)*alpham 
              do imat = 1,nmat
                 azfright(imat) = half*(-one-spzero )*alpha0f(imat)
                 azrright(imat) = half*(-one-spzero )*alpha0r(imat)
                 azeright(imat) = half*(-one-spzero )*alpha0e(imat)
              end do

              do imat = 1,nmat
                 rr = (r(imat)  )*gamh/gamc(imat)
                 ep = (e(imat)+p)*gamh/gamc(imat)
                 ir=imat; ie=imat+nmat
                 fp(l,i,j,k,ir,1) = f(imat) + (azfright(imat))
                 qp(l,i,j,k,ir,1) = r(imat) + (azrright(imat)+rr*(apright+amright))
                 qp(l,i,j,k,ie,1) = e(imat) + (azeright(imat)+ep*(apright+amright))
              end do
              qp(l,i,j,k,iu,1) = u + (apright-amright)*cc
              qp(l,i,j,k,ip,1) = p + (apright+amright)*pp

              ! Left state
              spminus = (u-ccc)*dtdx
              spplus  = (u+ccc)*dtdx
              spzero  = (u    )*dtdx
              if((u+ccc)<=zero)spplus =+project_out
              if((u-ccc)<=zero)spminus=+project_out
              if( u     <=zero)spzero =+project_out

              apleft   = half*(+one-spplus )*alphap
              amleft   = half*(+one-spminus)*alpham
              do imat = 1,nmat
                 azfleft(imat) = half*(+one-spzero )*alpha0f(imat)
                 azrleft(imat) = half*(+one-spzero )*alpha0r(imat)
                 azeleft(imat) = half*(+one-spzero )*alpha0e(imat)
              end do

              do imat = 1,nmat
                 rr = (r(imat)  )*gamh/gamc(imat)
                 ep = (e(imat)+p)*gamh/gamc(imat)
                 ir=imat; ie=imat+nmat
                 fm(l,i,j,k,ir,1) = f(imat) + (azfleft(imat))
                 qm(l,i,j,k,ir,1) = r(imat) + (azrleft(imat)+rr*(apleft+amleft))
                 qm(l,i,j,k,ie,1) = e(imat) + (azeleft(imat)+ep*(apleft+amleft))
              end do
              qm(l,i,j,k,iu,1) = u + (apleft-amleft)*cc
              qm(l,i,j,k,ip,1) = p + (apleft+amleft)*pp

           end do
        end do
     end do
  end do

end subroutine tracex
!###########################################################
!###########################################################
!###########################################################
!###########################################################
#if NDIM>1
subroutine tracexy(q,dq,c,qm,qp,dx,dy,dt,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  integer ::ngrid
  real(dp)::dx, dy, dt

  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar)::q  
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar,1:ndim)::dq 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar,1:ndim)::qm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar,1:ndim)::qp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2)::c  

  ! declare local variables
  integer ::ilo,ihi,jlo,jhi,klo,khi
  integer ::i, j, k, l, n
  integer ::ir, iu, iv, ip
  real(dp)::dtdx,dtdy,project_out
  real(dp)::cc, ccc, csq, r, u, v, p, a
  real(dp)::drx, dux, dvx, dpx, dax
  real(dp)::dry, duy, dvy, dpy, day
  real(dp)::alpham, alphap, alpha0r, alpha0u, alpha0v
  real(dp)::spminus, spplus, spzero
  real(dp)::apright, amright, azrright, azuright, azvright, azaright
  real(dp)::apleft,  amleft,  azrleft,  azuleft,  azvleft,  azaleft
  real(dp)::srx,sux,svx,spx,sax
  real(dp)::sry,suy,svy,spy,say
    
  dtdx = dt/dx; dtdy = dt/dy
  ilo=MIN(1,iu1+1); ihi=MAX(1,iu2-1)
  jlo=MIN(1,ju1+1); jhi=MAX(1,ju2-1)
  klo=MIN(1,ku1+1); khi=MAX(1,ku2-1)
  ir=1; iu=2; iv=3; ip=4
  project_out=one !zero

  do k = klo, khi
     do j = jlo, jhi
        do i = ilo, ihi
           do l = 1, ngrid

              ! cell centered values
              cc  = c  (l,i,j,k)
              r   = q  (l,i,j,k,ir)
              u   = q  (l,i,j,k,iu)
              v   = q  (l,i,j,k,iv)
              p   = q  (l,i,j,k,ip)
              csq = gamma*p/r

              ! TVD slopes in X and Y directions
              drx = dq(l,i,j,k,ir,1)
              dux = dq(l,i,j,k,iu,1)
              dvx = dq(l,i,j,k,iv,1)
              dpx = dq(l,i,j,k,ip,1)
              
              dry = dq(l,i,j,k,ir,2)
              duy = dq(l,i,j,k,iu,2)
              dvy = dq(l,i,j,k,iv,2)
              dpy = dq(l,i,j,k,ip,2)
              
              ! Transverse derivatives
              srx = half*dtdy*(-v*dry - (dvy)*r      )
              sux = half*dtdy*(-v*duy                )
              svx = half*dtdy*(-v*dvy - (dpy)/r      )
              spx = half*dtdy*(-v*dpy - (dvy)*gamma*p)

              sry = half*dtdx*(-u*drx - (dux)*r      )
              suy = half*dtdx*(-u*dux - (dpx)/r      )
              svy = half*dtdx*(-u*dvx                )
              spy = half*dtdx*(-u*dpx - (dux)*gamma*p)

              ! Characteristic analysis along X direction
              alpham  = half*(dpx/csq - dux*r/cc)
              alphap  = half*(dpx/csq + dux*r/cc)
              alpha0r = drx - dpx/csq
              alpha0v = dvx

              ! Supersonic fix for high-velocity gradients
              ccc = cc
              if(ABS(dux) > three*cc)ccc=zero

              ! Right state
              spminus = (u-ccc)*dtdx
              spplus  = (u+ccc)*dtdx
              spzero  = (u    )*dtdx
              if((u+ccc)>zero)spplus =-project_out
              if((u-ccc)>zero)spminus=-project_out
              if( u     >zero)spzero =-project_out

              apright  = half*(-one-spplus )*alphap 
              amright  = half*(-one-spminus)*alpham 
              azrright = half*(-one-spzero )*alpha0r
              azvright = half*(-one-spzero )*alpha0v

              qp(l,i,j,k,ir,1) = r + (apright+amright+azrright)     +srx
              qp(l,i,j,k,iu,1) = u + (apright-amright         )*cc/r+sux
              qp(l,i,j,k,ip,1) = p + (apright+amright         )*csq +spx
              qp(l,i,j,k,iv,1) = v + (                azvright)     +svx
              qp(l,i,j,k,ir,1) = max(smallr,qp(l,i,j,k,ir,1))

              ! Left state
              spminus = (u-ccc)*dtdx
              spplus  = (u+ccc)*dtdx
              spzero  = (u    )*dtdx
              if((u+ccc)<=zero)spplus =+project_out
              if((u-ccc)<=zero)spminus=+project_out
              if( u     <=zero)spzero =+project_out

              apleft   = half*(+one-spplus )*alphap 
              amleft   = half*(+one-spminus)*alpham 
              azrleft  = half*(+one-spzero )*alpha0r
              azvleft  = half*(+one-spzero )*alpha0v
              
              qm(l,i,j,k,ir,1) = r + (apleft+amleft+azrleft)     +srx
              qm(l,i,j,k,iu,1) = u + (apleft-amleft        )*cc/r+sux
              qm(l,i,j,k,ip,1) = p + (apleft+amleft        )*csq +spx
              qm(l,i,j,k,iv,1) = v + (              azvleft)     +svx
              qm(l,i,j,k,ir,1) = max(smallr, qm(l,i,j,k,ir,1))

              ! Characteristic analysis along Y direction
              alpham  = half*(dpy/csq - dvy*r/cc)
              alphap  = half*(dpy/csq + dvy*r/cc)
              alpha0r = dry - dpy/csq
              alpha0u = duy

              ! Supersonic fix for high-velocity gradients
              ccc = cc
              if(ABS(dvy) > three*cc)ccc=zero

              ! Top state
              spminus = (v-ccc)*dtdy
              spplus  = (v+ccc)*dtdy
              spzero  = (v    )*dtdy
              if((v+ccc)>zero)spplus =-project_out
              if((v-ccc)>zero)spminus=-project_out
              if( v     >zero)spzero =-project_out

              apright  = half*(-one-spplus )*alphap
              amright  = half*(-one-spminus)*alpham 
              azrright = half*(-one-spzero )*alpha0r
              azuright = half*(-one-spzero )*alpha0u

              qp(l,i,j,k,ir,2) = r + (apright+amright+azrright)     +sry
              qp(l,i,j,k,iv,2) = v + (apright-amright         )*cc/r+svy
              qp(l,i,j,k,ip,2) = p + (apright+amright         )*csq +spy
              qp(l,i,j,k,iu,2) = u + (                azuright)     +suy
              qp(l,i,j,k,ir,2) = max(smallr,qp(l,i,j,k,ir,2))

              ! Bottom state
              spminus = (v-ccc)*dtdy
              spplus  = (v+ccc)*dtdy
              spzero  = (v    )*dtdy
              if((v+ccc)<=zero)spplus =+project_out
              if((v-ccc)<=zero)spminus=+project_out
              if( v     <=zero)spzero =+project_out

              apleft   = half*(+one-spplus )*alphap
              amleft   = half*(+one-spminus)*alpham
              azrleft  = half*(+one-spzero )*alpha0r
              azuleft  = half*(+one-spzero )*alpha0u

              qm(l,i,j,k,ir,2) = r + (apleft+amleft+azrleft)     +sry
              qm(l,i,j,k,iv,2) = v + (apleft-amleft        )*cc/r+svy
              qm(l,i,j,k,ip,2) = p + (apleft+amleft        )*csq +spy
              qm(l,i,j,k,iu,2) = u + (              azuleft)     +suy
              qm(l,i,j,k,ir,2) = max(smallr, qm(l,i,j,k,ir,2))

           end do
        end do
     end do
  end do

  ! Passive scalars
  do n = ndim+3, nvar
     do k = klo, khi
        do j = jlo, jhi
           do i = ilo, ihi
              do l = 1, ngrid
                 a = q(l,i,j,k,n)     ! Cell centered values
                 u = q(l,i,j,k,iu)
                 v = q(l,i,j,k,iv)
                 dax = dq(l,i,j,k,n,1)    ! TVD slopes
                 day = dq(l,i,j,k,n,2)
                 sax = half*dtdy*(-v*day) ! Transverse
                 say = half*dtdx*(-u*dax) ! derivatives

                 ! Right state
                 spzero=(u    )*dtdx
                 if(u>zero)spzero=-project_out
                 azaright = half*(-one-spzero )*dax
                 qp(l,i,j,k,n,1) = a + azaright + sax
                 
                 ! Left state
                 spzero=(u    )*dtdx
                 if(u<=zero)spzero=+project_out
                 azaleft = half*(+one-spzero )*dax
                 qm(l,i,j,k,n,1) = a + azaleft + sax
                 
                 ! Top state
                 spzero=(v    )*dtdy
                 if(v>zero)spzero=-project_out
                 azaright = half*(-one-spzero )*day
                 qp(l,i,j,k,n,2) = a + azaright + say
                 
                 ! Bottom state
                 spzero=(v    )*dtdy
                 if(v<=zero)spzero=+project_out
                 azaleft = half*(+one-spzero )*day
                 qm(l,i,j,k,n,2) = a + azaleft + say
                 
              end do
           end do
        end do
     end do
  end do

end subroutine tracexy
#endif
!###########################################################
!###########################################################
!###########################################################
!###########################################################
#if NDIM>2
subroutine tracexyz(q,dq,c,qm,qp,dx,dy,dz,dt,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  integer ::ngrid
  real(dp)::dx,dy,dz, dt

  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar)::q  
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar,1:ndim)::dq 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar,1:ndim)::qm 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar,1:ndim)::qp 
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2)::c  

  ! declare local variables
  integer ::ilo,ihi,jlo,jhi,klo,khi
  integer ::i, j, k, l, n
  integer ::ir, iu, iv, iw, ip
  real(dp)::dtdx,dtdy,dtdz,project_out
  real(dp)::cc, ccc, csq, r, u, v, w, p, a
  real(dp)::drx, dux, dvx, dwx, dpx, dax
  real(dp)::dry, duy, dvy, dwy, dpy, day
  real(dp)::drz, duz, dvz, dwz, dpz, daz
  real(dp)::alpham, alphap, alpha0r, alpha0u, alpha0v, alpha0w
  real(dp)::spminus, spplus, spzero
  real(dp)::apright, amright, azrright, azuright, azvright, azwright, azaright
  real(dp)::apleft,  amleft,  azrleft,  azuleft,  azvleft,  azwleft,  azaleft
  real(dp)::srx,sux,svx,swx,spx,sax
  real(dp)::sry,suy,svy,swy,spy,say
  real(dp)::srz,suz,svz,swz,spz,saz
    
  dtdx = dt/dx; dtdy = dt/dy; dtdz = dt/dz
  ilo=MIN(1,iu1+1); ihi=MAX(1,iu2-1)
  jlo=MIN(1,ju1+1); jhi=MAX(1,ju2-1)
  klo=MIN(1,ku1+1); khi=MAX(1,ku2-1)
  ir=1; iu=2; iv=3; iw=4; ip=5
  project_out=one !zero
  
  do k = klo, khi
     do j = jlo, jhi
        do i = ilo, ihi
           do l = 1, ngrid
  
              ! Cell centered values
              cc  = c  (l,i,j,k)
              r   = q  (l,i,j,k,ir)
              u   = q  (l,i,j,k,iu)
              v   = q  (l,i,j,k,iv)
              w   = q  (l,i,j,k,iw)
              p   = q  (l,i,j,k,ip)
              csq = gamma*p/r

              ! TVD slopes in all 3 directions
              drx = dq(l,i,j,k,ir,1)
              dux = dq(l,i,j,k,iu,1)
              dvx = dq(l,i,j,k,iv,1)
              dwx = dq(l,i,j,k,iw,1)
              dpx = dq(l,i,j,k,ip,1)
              
              dry = dq(l,i,j,k,ir,2)
              duy = dq(l,i,j,k,iu,2)
              dvy = dq(l,i,j,k,iv,2)
              dwy = dq(l,i,j,k,iw,2)
              dpy = dq(l,i,j,k,ip,2)
              
              drz = dq(l,i,j,k,ir,3)
              duz = dq(l,i,j,k,iu,3)
              dvz = dq(l,i,j,k,iv,3)
              dwz = dq(l,i,j,k,iw,3)
              dpz = dq(l,i,j,k,ip,3)

              ! Transverse derivatives
              srx = half*dtdx*(-v*dry-w*drz - (dvy+dwz)*r      )
              spx = half*dtdx*(-v*dpy-w*dpz - (dvy+dwz)*gamma*p)
              sux = half*dtdx*(-v*duy-w*duz                    )
              svx = half*dtdx*(-v*dvy-w*dvz - (dpy)/r          )
              swx = half*dtdx*(-v*dwy-w*dwz - (dpz)/r          )

              sry = half*dtdx*(-u*drx-w*drz - (dux+dwz)*r      )
              spy = half*dtdx*(-u*dpx-w*dpz - (dux+dwz)*gamma*p)
              suy = half*dtdx*(-u*dux-w*duz - (dpx)/r          )
              svy = half*dtdx*(-u*dvx-w*dvz                    )
              swy = half*dtdx*(-u*dwx-w*dwz - (dpz)/r          )

              srz = half*dtdx*(-v*dry-u*drx - (dvy+dux)*r      )
              spz = half*dtdx*(-v*dpy-u*dpx - (dvy+dux)*gamma*p)
              suz = half*dtdx*(-v*duy-u*dux - (dpx)/r          )
              svz = half*dtdx*(-v*dvy-u*dvx - (dpy)/r          )
              swz = half*dtdx*(-v*dwy-u*dwx                    )

              ! Characteristic analysis along X direction
              alpham  = half*(dpx/csq - dux*r/cc)
              alphap  = half*(dpx/csq + dux*r/cc)
              alpha0r = drx - dpx/csq
              alpha0v = dvx
              alpha0w = dwx

              ! Supersonic fix for high-velocity gradients
              ccc = cc
              if(ABS(dux) > three*cc)ccc=zero

              ! Right state
              spminus = (u-ccc)*dtdx
              spplus  = (u+ccc)*dtdx
              spzero  = (u    )*dtdx
              if((u+ccc)>zero)spplus =-project_out
              if((u-ccc)>zero)spminus=-project_out
              if( u     >zero)spzero =-project_out

              apright  = half*(-one-spplus )*alphap
              amright  = half*(-one-spminus)*alpham
              azrright = half*(-one-spzero )*alpha0r
              azvright = half*(-one-spzero )*alpha0v
              azwright = half*(-one-spzero )*alpha0w

              qp(l,i,j,k,ir,1) = r + (apright+amright+azrright)     +srx
              qp(l,i,j,k,iu,1) = u + (apright-amright         )*cc/r+sux
              qp(l,i,j,k,ip,1) = p + (apright+amright         )*csq +spx
              qp(l,i,j,k,iv,1) = v + (                azvright)     +svx
              qp(l,i,j,k,iw,1) = w + (                azwright)     +swx
              qp(l,i,j,k,ir,1) = max(smallr,qp(l,i,j,k,ir,1))

              ! Left state
              spminus = (u-ccc)*dtdx
              spplus  = (u+ccc)*dtdx
              spzero  = (u    )*dtdx
              if((u+ccc)<=zero)spplus =+project_out
              if((u-ccc)<=zero)spminus=+project_out
              if( u     <=zero)spzero =+project_out

              apleft   = half*(+one-spplus )*alphap
              amleft   = half*(+one-spminus)*alpham
              azrleft  = half*(+one-spzero )*alpha0r
              azvleft  = half*(+one-spzero )*alpha0v
              azwleft  = half*(+one-spzero )*alpha0w

              qm(l,i,j,k,ir,1) = r + (apleft+amleft+azrleft)     +srx
              qm(l,i,j,k,iu,1) = u + (apleft-amleft        )*cc/r+sux
              qm(l,i,j,k,ip,1) = p + (apleft+amleft        )*csq +spx
              qm(l,i,j,k,iv,1) = v + (              azvleft)     +svx
              qm(l,i,j,k,iw,1) = w + (              azwleft)     +swx
              qm(l,i,j,k,ir,1) = max(smallr, qm(l,i,j,k,ir,1))

              ! Characteristic analysis along Y direction
              alpham  = half*(dpy/csq - dvy*r/cc)
              alphap  = half*(dpy/csq + dvy*r/cc)
              alpha0r = dry - dpy/csq
              alpha0u = duy
              alpha0w = dwy

              ! Supersonic fix for high-velocity gradients
              ccc = cc
              if(ABS(dvy) > three*cc)ccc=zero

              ! Top state
              spminus = (v-ccc)*dtdy
              spplus  = (v+ccc)*dtdy
              spzero  = (v    )*dtdy
              if((v+ccc)>zero)spplus =-project_out
              if((v-ccc)>zero)spminus=-project_out
              if( v     >zero)spzero =-project_out

              apright  = half*(-one-spplus )*alphap 
              amright  = half*(-one-spminus)*alpham 
              azrright = half*(-one-spzero )*alpha0r
              azuright = half*(-one-spzero )*alpha0u
              azwright = half*(-one-spzero )*alpha0w

              qp(l,i,j,k,ir,2) = r + (apright+amright+azrright)     +sry
              qp(l,i,j,k,iv,2) = v + (apright-amright         )*cc/r+svy
              qp(l,i,j,k,ip,2) = p + (apright+amright         )*csq +spy
              qp(l,i,j,k,iu,2) = u + (                azuright)     +suy
              qp(l,i,j,k,iw,2) = w + (                azwright)     +swy
              qp(l,i,j,k,ir,2) = max(smallr,qp(l,i,j,k,ir,2))

              ! Bottom state
              spminus = (v-ccc)*dtdy
              spplus  = (v+ccc)*dtdy
              spzero  = (v    )*dtdy
              if((v+ccc)<=zero)spplus =+project_out
              if((v-ccc)<=zero)spminus=+project_out
              if( v     <=zero)spzero =+project_out

              apleft   = half*(+one-spplus )*alphap 
              amleft   = half*(+one-spminus)*alpham 
              azrleft  = half*(+one-spzero )*alpha0r
              azuleft  = half*(+one-spzero )*alpha0u
              azwleft  = half*(+one-spzero )*alpha0w

              qm(l,i,j,k,ir,2) = r + (apleft+amleft+azrleft)     +sry
              qm(l,i,j,k,iv,2) = v + (apleft-amleft        )*cc/r+svy
              qm(l,i,j,k,ip,2) = p + (apleft+amleft        )*csq +spy
              qm(l,i,j,k,iu,2) = u + (              azuleft)     +suy
              qm(l,i,j,k,iw,2) = w + (              azwleft)     +swy
              qm(l,i,j,k,ir,2) = max(smallr, qm(l,i,j,k,ir,2))

              ! Characteristic analysis along Z direction
              alpham  = half*(dpz/csq - dwz*r/cc)
              alphap  = half*(dpz/csq + dwz*r/cc)
              alpha0r = drz - dpz/csq
              alpha0u = duz
              alpha0v = dvz

              ! Supersonic fix for high-velocity gradients
              ccc = cc
              if(ABS(dwz) > three*cc)ccc=zero

              ! Front state
              spminus = (w-ccc)*dtdz
              spplus  = (w+ccc)*dtdz
              spzero  = (w    )*dtdz
              if((w+ccc)>zero)spplus =-project_out
              if((w-ccc)>zero)spminus=-project_out
              if( w     >zero)spzero =-project_out

              apright  = half*(-one-spplus )*alphap 
              amright  = half*(-one-spminus)*alpham 
              azrright = half*(-one-spzero )*alpha0r
              azuright = half*(-one-spzero )*alpha0u
              azvright = half*(-one-spzero )*alpha0v

              qp(l,i,j,k,ir,3) = r + (apright+amright+azrright)     +srz
              qp(l,i,j,k,iw,3) = w + (apright-amright         )*cc/r+swz
              qp(l,i,j,k,ip,3) = p + (apright+amright         )*csq +spz
              qp(l,i,j,k,iu,3) = u + (                azuright)     +suz
              qp(l,i,j,k,iv,3) = v + (                azvright)     +svz
              qp(l,i,j,k,ir,3) = max(smallr,qp(l,i,j,k,ir,3))

              ! Back state
              spminus = (w-ccc)*dtdz
              spplus  = (w+ccc)*dtdz
              spzero  = (w    )*dtdz
              if((w+ccc)<=zero)spplus =+project_out
              if((w-ccc)<=zero)spminus=+project_out
              if( w     <=zero)spzero =+project_out

              apleft   = half*(+one-spplus )*alphap 
              amleft   = half*(+one-spminus)*alpham 
              azrleft  = half*(+one-spzero )*alpha0r
              azuleft  = half*(+one-spzero )*alpha0u
              azvleft  = half*(+one-spzero )*alpha0v

              qm(l,i,j,k,ir,3) = r + (apleft+amleft+azrleft)     +srz
              qm(l,i,j,k,iw,3) = w + (apleft-amleft        )*cc/r+swz
              qm(l,i,j,k,ip,3) = p + (apleft+amleft        )*csq +spz
              qm(l,i,j,k,iu,3) = u + (              azuleft)     +suz
              qm(l,i,j,k,iv,3) = v + (              azvleft)     +svz
              qm(l,i,j,k,ir,3) = max(smallr, qm(l,i,j,k,ir,3))
           end do

        end do
     end do
  end do

  ! Passive scalars
  do n = ndim+3, nvar
     do k = klo, khi
        do j = jlo, jhi
           do i = ilo, ihi
              do l = 1, ngrid
                 a   =  q(l,i,j,k,n)    ! Cell centered values
                 u   =  q(l,i,j,k,iu)
                 v   =  q(l,i,j,k,iv)
                 w   =  q(l,i,j,k,iw)
                 dax = dq(l,i,j,k,n,1)  ! TVD slopes
                 day = dq(l,i,j,k,n,2)
                 daz = dq(l,i,j,k,n,3)
                 sax = half*dtdx*(-v*day-w*daz) ! Transverse
                 say = half*dtdx*(-u*dax-w*daz) ! derivatives
                 saz = half*dtdx*(-v*day-u*dax) ! 

                 
                 ! Right state
                 spzero = (u    )*dtdx
                 if(u>zero)spzero=-project_out
                 azaright = half*(-one-spzero )*dax
                 qp(l,i,j,k,n,1) = a + azaright + sax
                 
                 ! Left state
                 spzero = (u    )*dtdx
                 if(u<=zero)spzero=+project_out
                 azaleft = half*(+one-spzero )*dax
                 qm(l,i,j,k,n,1) = a + azaleft + sax

                 ! Top state
                 spzero = (v    )*dtdy
                 if(v>zero)spzero=-project_out
                 azaright = half*(-one-spzero )*day
                 qp(l,i,j,k,n,2) = a + azaright + say
                 
                 ! Bottom state
                 spzero = (v    )*dtdy
                 if(v<=zero)spzero=+project_out
                 azaleft = half*(+one-spzero )*day
                 qm(l,i,j,k,n,2) = a + azaleft + say

                 ! Front state
                 spzero = (w    )*dtdy
                 if(w>zero)spzero=-project_out
                 azaright = half*(-one-spzero )*daz
                 qp(l,i,j,k,n,3) = a + azaright + saz
                 
                 ! Back state
                 spzero = (w    )*dtdy
                 if(w<=zero)spzero=+project_out
                 azaleft = half*(+one-spzero )*daz
                 qm(l,i,j,k,n,3) = a + azaleft + saz
              end do
           end do
        end do
     end do
  end do

end subroutine tracexyz
#endif
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine cmpdivu(q,div,dx,dy,dz,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  integer ::ngrid
  real(dp)::dx, dy, dz
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar)::q  
  real(dp),dimension(1:nvector,if1:if2,jf1:jf2,kf1:kf2)::div

  integer::i, j, k, l
  real(dp)::factorx, factory, factorz
  real(dp),dimension(1:nvector)::ux, vy, wz

  factorx=half**(ndim-1)/dx
  factory=half**(ndim-1)/dy
  factorz=half**(ndim-1)/dz

  do k = kf1, kf2
     do j = jf1, jf2
        do i = if1, if2

           ux = zero; vy=zero; wz=zero

           if(ndim>0)then
              do l=1, ngrid
                 ux(l)=ux(l)+factorx*(q(l,i  ,j  ,k  ,2) - q(l,i-1,j  ,k  ,2))
              end do
           end if

#if NDIM>1           
           do l=1, ngrid
              ux(l)=ux(l)+factorx*(q(l,i  ,j-1,k  ,2) - q(l,i-1,j-1,k  ,2))
              vy(l)=vy(l)+factory*(q(l,i  ,j  ,k  ,3) - q(l,i  ,j-1,k  ,3)+&
                   &               q(l,i-1,j  ,k  ,3) - q(l,i-1,j-1,k  ,3))
           end do
#endif
#if NDIM>2
           do l=1, ngrid
              ux(l)=ux(l)+factorx*(q(l,i  ,j  ,k-1,2) - q(l,i-1,j  ,k-1,2)+&
                   &               q(l,i  ,j-1,k-1,2) - q(l,i-1,j-1,k-1,2))
              vy(l)=vy(l)+factory*(q(l,i  ,j  ,k-1,3) - q(l,i  ,j-1,k-1,3)+&
                   &               q(l,i-1,j  ,k-1,3) - q(l,i-1,j-1,k-1,3))
              wz(l)=wz(l)+factorz*(q(l,i  ,j  ,k  ,4) - q(l,i  ,j  ,k-1,4)+&
                   &               q(l,i  ,j-1,k  ,4) - q(l,i  ,j-1,k-1,4)+&
                   &               q(l,i-1,j  ,k  ,4) - q(l,i-1,j  ,k-1,4)+&
                   &               q(l,i-1,j-1,k  ,4) - q(l,i-1,j-1,k-1,4))
           end do
#endif
           do l=1,ngrid
              div(l,i,j,k) = ux(l) + vy(l) + wz(l)
           end do

        end do
     end do
  end do

end subroutine cmpdivu
!###########################################################
!###########################################################
!###########################################################
!###########################################################
subroutine consup(uin,flux,div,dt,ngrid)
  use amr_parameters
  use hydro_parameters
  use const
  implicit none

  integer ::ngrid
  real(dp)::dt
  real(dp),dimension(1:nvector,iu1:iu2,ju1:ju2,ku1:ku2,1:nvar)::uin 
  real(dp),dimension(1:nvector,if1:if2,jf1:jf2,kf1:kf2,1:nvar,1:ndim)::flux
  real(dp),dimension(1:nvector,if1:if2,jf1:jf2,kf1:kf2)::div 

  integer:: i, j, k, l, n
  real(dp)::factor
  real(dp),dimension(1:nvector),save:: div1

  factor=half**(ndim-1)

  ! Add diffusive flux where flow is compressing
  do n = 1, nvar

     do k = kf1, MAX(kf1,ku2-2)
        do j = jf1, MAX(jf1, ju2-2) 
           do i = if1, if2

              div1 = zero
              do l = 1, ngrid
                 div1(l) = factor*div(l,i,j,k)
              end do
#if NDIM>1
              do l = 1, ngrid
                 div1(l)=div1(l)+factor*div(l,i,j+1,k)
              end do
#endif
#if NDIM>2
              do l = 1, ngrid
                 div1(l)=div1(l)+factor*(div(l,i,j,k+1)+div(l,i,j+1,k+1))
                 div1(l)=difmag*min(zero,div1(l))
              end do
#endif
              do l = 1, ngrid
                 div1(l) = difmag*min(zero,div1(l))
              end do
              do l = 1, ngrid
                 flux(l,i,j,k,n,1) = flux(l,i,j,k,n,1) + &
                      &  dt*div1(l)*(uin(l,i,j,k,n) - uin(l,i-1,j,k,n))
              end do

           end do
        end do
     end do

#if NDIM>1
     do k = kf1, MAX(kf1,ku2-2)
        do j = jf1, jf2
           do i = iu1+2, iu2-2

              div1 = zero
              do l = 1, ngrid
                 div1(l)=div1(l)+factor*(div(l,i,j,k ) + div(l,i+1,j,k))
              end do
              if(ndim>2)then
                 do l = 1, ngrid
                    div1(l)=div1(l)+factor*(div(l,i,j,k+1) + div(l,i+1,j,k+1))
                 end do
              end if
              do l = 1, ngrid
                 div1(l) = difmag*min(zero,div1(l))
              end do
              do l = 1, ngrid
                 flux(l,i,j,k,n,2) = flux(l,i,j,k,n,2) + &
                      &  dt*div1(l)*(uin(l,i,j,k,n) - uin(l,i,j-1,k,n))
              end do

           end do
        end do
     end do
#endif

#if NDIM>2
     do k = kf1, kf2
        do j = ju1+2, ju2-2 
           do i = iu1+2, iu2-2 

              do l = 1, ngrid
                 div1(l)=factor*(div(l,i,j  ,k) + div(l,i+1,j  ,k) &
                      &        + div(l,i,j+1,k) + div(l,i+1,j+1,k))
              end do
              do l = 1, ngrid
                 div1(l) = difmag*min(zero,div1(l))
              end do
              do l = 1, ngrid
                 flux(l,i,j,k,n,3) = flux(l,i,j,k,n,3) + &
                      &  dt*div1(l)*(uin(l,i,j,k,n) - uin(l,i,j,k-1,n))
              end do
           end do
        end do
     end do
#endif

  end do

end subroutine consup
../patch/multimat/write_screen.f90
subroutine write_screen
  use amr_commons
  use hydro_commons
  use pm_commons
  use poisson_commons
  use mpi_mod
  implicit none
#ifndef WITHOUTMPI
  integer::info
#endif
  integer::igrid,jgrid,ind,icpu
  integer::i,icell,ncell,ilevel,ncache
  integer::icellmin,imat,lll
  real(dp)::dx,scale,smallp,ddd

  integer     ,dimension(:),allocatable::ind_grid,ind_cell,ind_sort,ll,ll_all
  real(kind=8),dimension(:),allocatable::rr,rr_all
  real(kind=8),dimension(:,:),allocatable::qq,qq_all,ff,ff_all,gg,gg_all
  real(dp),dimension(1:nvector),save::ppp,ccc,kappa_hattt
  real(dp),dimension(1:nvector,1:nmat),save::fff,ggg,kappa_mattt
  real(dp),dimension(1:nvector,1:npri),save::qqq

  integer,dimension(1:ncpu)::iskip,ncell_loc,ncell_all
  real(dp)::uuu,rrr,dtot

  if(ndim>1)return

#ifndef WITHOUTMPI
  call MPI_BARRIER(MPI_COMM_WORLD,info)
#endif
  
  ncell=0
  do ilevel=1,nlevelmax
     ncache=numbl(myid,ilevel)
     if(ncache > 0)then
        allocate(ind_grid(1:ncache),ind_cell(1:ncache))
        ! Gather all grids
        igrid=headl(myid,ilevel)
        do jgrid=1,ncache
           ind_grid(jgrid)=igrid
           igrid=next(igrid)
        end do
        ! Count leaf cells
        do ind=1,twotondim
           do i=1,ncache
              ind_cell(i)=ncoarse+(ind-1)*ngridmax+ind_grid(i)
           end do
           do i=1,ncache
              if(son(ind_cell(i))== 0)then
                 ncell=ncell+1
              end if
           end do
        end do
        deallocate(ind_grid, ind_cell)
     end if
  end do

  ncell_loc=0
  ncell_all=0
  ncell_loc(myid)=ncell
#ifndef WITHOUTMPI
  call MPI_ALLREDUCE(ncell_loc,ncell_all,ncpu,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)
#endif
#ifdef WITHOUTMPI
  ncell_all=ncell_loc
#endif

  ncell=0
  iskip=0
  do icpu=1,ncpu
     iskip(icpu)=ncell
     ncell=ncell+ncell_all(icpu)
  end do

  if(myid==1)write(*,114)ncell

  if(ncell>0)then

  allocate(rr(1:ncell)       ,rr_all(1:ncell))
  allocate(ll(1:ncell)       ,ll_all(1:ncell))
  allocate(ff(1:ncell,1:nmat),ff_all(1:ncell,1:nmat))
  allocate(gg(1:ncell,1:nmat),gg_all(1:ncell,1:nmat))
  allocate(qq(1:ncell,1:npri),qq_all(1:ncell,1:npri))
  rr    =0.0D0; ll    =0; ff    =0.0; gg    =0.0; qq    =0.0
  rr_all=0.0D0; ll_all=0; ff_all=0.0; gg_all=0.0; qq_all=0.0

  icell=iskip(myid)
  do ilevel=1,nlevelmax
     icellmin=icell
     ncache=numbl(myid,ilevel)
     if(ncache > 0)then
        dx=0.5D0**ilevel
        allocate(ind_grid(1:ncache),ind_cell(1:ncache))
        ! Gather all grids
        igrid=headl(myid,ilevel)
        do jgrid=1,ncache
           ind_grid(jgrid)=igrid
           igrid=next(igrid)
        end do
        ! Gather variables
        icell=icellmin
        do ind=1,twotondim
           do i=1,ncache
              ind_cell(i)=ncoarse+(ind-1)*ngridmax+ind_grid(i)
           end do
           do i=1,ncache
              if(son(ind_cell(i))==0)then
                 icell=icell+1
                 rr(icell)=xg(ind_grid(i),1)+(dble(ind)-1.5D0)*dx
                 ll(icell)=ilevel
              end if
           end do
        end do
        if(hydro)then
           icell=icellmin
           do ind=1,twotondim
              do i=1,ncache
                 ind_cell(i)=ncoarse+(ind-1)*ngridmax+ind_grid(i)
              end do
              do i=1,ncache
                 if(son(ind_cell(i))==0)then
                    icell=icell+1
                    qq(icell,1)=uold(ind_cell(i),1)
                    qq(icell,2)=uold(ind_cell(i),2)/qq(icell,1)
                    qq(icell,3)=uold(ind_cell(i),3)-0.5*qq(icell,1)*qq(icell,2)**2
                    do imat=1,nmat
                       ff(icell,imat)=uold(ind_cell(i),imat+npri)
                       gg(icell,imat)=uold(ind_cell(i),imat+npri+nmat)
                    end do
                 end if
              end do
           end do
        end if
        deallocate(ind_grid, ind_cell)
     end if
  end do

#ifndef WITHOUTMPI
  call MPI_ALLREDUCE(ff,ff_all,ncell*nmat,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)
  call MPI_ALLREDUCE(gg,gg_all,ncell*nmat,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)
  call MPI_ALLREDUCE(qq,qq_all,ncell*npri,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)
  call MPI_ALLREDUCE(ll,ll_all,ncell     ,MPI_INTEGER         ,MPI_SUM,MPI_COMM_WORLD,info)
  call MPI_ALLREDUCE(rr,rr_all,ncell     ,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)
  ff=ff_all; gg=gg_all; qq=qq_all; rr=rr_all; ll=ll_all
#endif

  if(myid==1)then
     write(*,*)'================================================'
     write(*,*)'lev      x           d          u          P        f1         f2         d1         d2'
     ! Sort radius
     allocate(ind_sort(1:ncell))
     call quick_sort(rr,ind_sort,ncell)
     ! Write results to screen
     scale=boxlen/dble(icoarse_max-icoarse_min+1)
     do i=1,ncell
        ! Call eos routine
        fff(1,1:nmat)=ff(ind_sort(i),1:nmat)
        ggg(1,1:nmat)=gg(ind_sort(i),1:nmat)
        qqq(1,1:npri)=qq(ind_sort(i),1:npri)
        call eos(fff,ggg,qqq,ppp,ccc,kappa_mattt,kappa_hattt,1)
        lll=ll(ind_sort(i))
        rrr=(rr(i)-dble(icoarse_min))*scale
        ddd=qqq(1,1)
        uuu=qqq(1,2)
        if(ABS(uuu).lt.1d-15)uuu=0.0
        ppp(1)=ppp(1)
        write(*,113) &
             & lll,  &
             & rrr, &
             & ddd, &
             & uuu, &
             & ppp(1), &
             & (fff(1,imat),imat=1,nmat) , &
             & (ggg(1,imat),imat=1,nmat)
     end do
     deallocate(ind_sort)
  end if

  ! Deallocate local arrays
  deallocate(ff,qq,rr,ll)
  deallocate(ff_all,qq_all,rr_all,ll_all)

  end if
 
#ifndef WITHOUTMPI
  call MPI_BARRIER(MPI_COMM_WORLD,info)
#endif

111 format(2(1pe12.5,1x))
112 format(i3,1x,1pe10.3,1x,8(1pe10.3,1x))
113 format(i3,1x,1pe12.5,1x,9(1pe10.3,1x))
114 format(' Output ',i5,' cells')
115 format(' Output ',i5,' parts')

end subroutine write_screen
